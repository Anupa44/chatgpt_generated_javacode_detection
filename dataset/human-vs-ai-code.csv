Code,Label
"public class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] resultat=new int[2];
        for(int i=0;i<nums.length;i++){
           for(int j=i+1;j<nums.length;j++){
               if(nums[i]+nums[j]==target){
                   resultat[0]=i;
                   resultat[1]=j;
               }
           }

        }
        return resultat;

    }
}",0
"/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode result = new ListNode();
        ListNode tempNode = result;
        int temp = 0;
        while(l1 != null || l2 != null || temp != 0){
            int sum = ((l1 != null) ? l1.val : 0) + ((l2 != null ) ? l2.val : 0) + temp;
            if(sum > 9){
                sum = sum % 10;
                temp = 1;
            }else{
                temp =0;
            }
            ListNode newNode = new ListNode(sum);
            tempNode.next = newNode;
            tempNode = tempNode.next;
            l1 = ((l1 != null) ? l1.next : l1);
            l2 = ((l2 != null) ? l2.next : l2);
        }
        return result.next;
    }
}",0
" class Solution {
    public boolean isPalindrome(int x) {
        int palindrome = x ; 
        int rev = 0 ; 
        while(palindrome!=0){
            int lastdigit = palindrome%10;
            rev = (rev*10)+lastdigit;
            palindrome = palindrome/10;
        }
        if(x> 0 && x == rev || x==0) {
            return true ;
        }
        return false ;
    }
}",0
"class Solution {
    
    public int romanToInt(String s) {
        Map<String, Integer> romanNums = new HashMap<>();
        romanNums.put( ""I"",1);
        romanNums.put(
            ""V"",5
        );
        romanNums.put(
            ""X"",10
        );
        romanNums.put(
            ""L"",50
        );
        romanNums.put(
            ""C"",100
        );

        romanNums.put(
            ""D"",500
        );
        romanNums.put(
            ""M"",1000
        );
        romanNums.put(""IV"",4);
        romanNums.put(""IX"",9);
        romanNums.put(""XL"",40);
        romanNums.put(""XC"",90);
        romanNums.put(""CD"",400);
        romanNums.put(""CM"",900);



        // get list of index of exception maps
        // such as and keep track it
        // interate over the roman number string.
        // get int from map and add it up, if there meet one of 6 instances
        // get value from exp map.
        int res =0;
        int index = 0;
        while(index < s.length()){
            // check of next symbol
            if (index +1 < s.length()){
                String tempVal = s.subString(index, index+1);
                if(romanNums.containsKey(tempVal)){
                    res += romanNums.get(tempVal); 
                    index += 2;
                    continue;
                }else{
                    res += romanNums.get(s.charAt(index));
                    index += 1;
                }
                
            }else{
                res += romanNums.get(s.charAt(index));
                index += 1;
            }
        }
       
        return res;
    }
}",0
"class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        int n = strs.length - 1;
        String s = strs[0];
        String s1 = strs[n];
        int i = 0;
        while (i < s.length() && i < s1.length()) {
            if (s.charAt(i) == s1.charAt(i)) {
                i++;
            } else {
                break;
            }
        }
        return s.substring(0, i);
    }
}",0
"class Solution {
    public boolean isValid(String s) {
    Stack<Character>stack=new Stack<>();
    HashMap<Character,Character>map=new HashMap<>();
    map.put(')','(');map.put(']','[');map.put('}','{');
    for(char c:s.toCharArray()){
        if(map.containsKey(c)){
          if(stack.isEmpty()){
            return false;
          } 
          else{
            if(stack.peek()==map.get(c)){
                stack.pop();
            }
            else{
                stack.push(c);
            }
          }
          continue;
        }
        stack.push(c);

    }
    if(stack.isEmpty()){
        return true;
    }
    return false;
    }
}",0
"/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
                if(list1!=null && list2!=null){
        if(list1.val<list2.val){
            list1.next=mergeTwoLists(list1.next,list2);
            return list1;
            }
            else{
                list2.next=mergeTwoLists(list1,list2.next);
                return list2;
        }
        }
        if(list1==null)
            return list2;
        return list1;
    }
}",0
"class Solution {
    public int removeDuplicates(int[] nums) {
        int count = 0;
        for(int i=0;i<nums.length; i++){
            if(nums[i] != nums[count]){
                count++;
                nums[count] = nums[i];
                }
            }
        
        return count+1;
    }
    
}",0
"class Solution {
    public int removeElement(int[] nums, int val) {
        int i=0,j=nums.length-1;
        // if( nums.length == 1 && nums[0] == val ) {
        //     return 0;
        // }
        while( i<j ) {
            if ( nums[j] == val ) {
                j--;
            }
            else if ( nums[i] == val ){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
                j--;
            }
            else{
                i++;
            }
        }
        if ( nums.length == 0 || nums[0] == val ) {
            return 0;
        }
        if ( nums[i] == val ) {
            return i;
        }
        return i+1;
    }
}",0
"class Solution {
    public int strStr(String haystack, String needle) {
        int n=haystack.length();
        int m=needle.length();
        int c=0;
        int j=0;
        for(int i=0;i<n;i++) {
            if(haystack.charAt(i)==needle.charAt(j) && j<m) {
                if(j==m-1) {
                    return i-j;
                }
                j++;
                c++;
            }
            else if( haystack.charAt(i)!=needle.charAt(j) ) {
                i=i-j;
                j=0;

            }
        }
        return -1;
    }
}",0
"class Solution {
    public int searchInsert(int[] nums, int target) {
        int l=0,h=nums.length-1;
        while(l<=h){
            int mid = l+(h-l)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]>target){
                h=mid-1;
            }
            else{
                l=mid+1;
            }
        }
        return l;
    }
}",0
"class Solution {
    public int lengthOfLastWord(String s) {
        int length = 0;

        for(int i=s.length()-1 ; i>=0 ; i--)
        {
            if(s.charAt(i)!= ' ')
                length++;
            else
                if(length>0) return length;
        }
        return length;
    }
}",0
"class Solution {
    StringBuilder s=new StringBuilder();
    public int[] plusOne(int[] digits) {
        for(int i=(digits.length)-1;i >= 0;i--){
            if(digits[i]<9){
                digits[i]=digits[i]+1;
                return digits;
            }else if(digits[i]==9){
                digits[i]=0;
            }   
        }
        int[] newarr=new int[digits.length+1];
        newarr[0]=1;
        return newarr;
    }
}",0
"public String addBinary(String s1, String s2) {
    int i = s1.length() - 1, j = s2.length() - 1, c = 0;
    String s = """";
    
    while (i >= 0 || j >= 0 || c == 1) {
        int a = (i < 0) ? 0 : s1.charAt(i--) - '0';
        int b = (j < 0) ? 0 : s2.charAt(j--) - '0';
        
        s = (char)('0' + a ^ b ^ c) + s;
        c = (a + b + c) >> 1;
    }
    
    return s;
}",0
"class Solution {
    public int mySqrt(int x) {

     if(x==0 || x==1){
        return x;
     }

     double n=0;
     double sq=x/2;

     do{
        n=sq;
        sq=(n+(x/n))/2;

     }while(n-sq!=0);

    return (int)sq;

    }
}",0
"class Solution {
    public int climbStairs(int n) {

        int dp[] = new int [n+2];
        dp[1] = 1;
        dp[0] = 1;
        for(int i=2;i<=n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}",0
"/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode curr=head;
 
         if(head==null)
         {
            return null;
         }
        while(curr.next!=null )
        {
            if(curr.val==curr.next.val)
            {
                curr.next=curr.next.next;
              
            }
            else
            {
                curr=curr.next;
            }
        }
        return head;
    }
}",0
"class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        
        int i = m -1;
        int j = n -1;
        int k = m + n -1;

        while(j >= 0){
            if(i >= 0 && nums1[i] > nums2[j]){
                nums1[k] = nums1[i];
                k--;
                i--;
            }else{
                nums1[k] = nums2[j];
                k--;
                j--;
            }
        }

    }
    
}",0
"
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        traverse(root, res);
        return res;
    }
    public static void traverse(TreeNode root, List<Integer> ds){
        if(root == null){
            return;
        }
        traverse(root.left, ds);
        ds.add(root.val);
        traverse(root.right, ds);
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // check base case
        if (p == null && q == null)
            return true;
        if (p == null || q == null)
            return false;

        // Now check the values
        if (p.val != q.val)
            return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}",0
"class Solution {
    public boolean helper(TreeNode left, TreeNode right) {
        if (left == null && right == null) return true;
        if (left == null || right == null) return false;

        if (left.val != right.val) return false;

        return helper(left.left, right.right) && helper(left.right, right.left);
    }

    public boolean isSymmetric(TreeNode root) {
        return helper(root.left, root.right);
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution 
{
    public int maxDepth(TreeNode root) 
    {
        if(root==null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        return constructBST(nums, 0, nums.length - 1);
    }
    
    private TreeNode constructBST(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        
        root.left = constructBST(nums, left, mid - 1);
        root.right = constructBST(nums, mid + 1, right);
        
        return root;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public int height(TreeNode root){
        if(root == null){
            return 0;
        }
        int l = height (root.left);
        int r = height(root.right);

        int out = 0;

        if (l == -1 || r == -1)  return -1;
        if (Math.abs(l - r) > 1)  return -1;
        
return Math.max(l, r) + 1;

        
    }

    
    public boolean isBalanced(TreeNode root) {

        if(root == null){
            return true;
        }

        if (height(root) == -1)  return false;
return true;  
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
          if (root==null)
            return 0;
        else if(root.left==null && root.right == null)
            return 1;
        else if(root.left == null)
            return 1 + minDepth(root.right);
        else if(root.right == null)
            return 1 + minDepth(root.left);
        else
            return 1 + Math.min(minDepth(root.left), minDepth(root.right));
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){ return false;}
         if(root.left == null && root.right == null)

        {
            return targetSum == root.val;
        }

        boolean lSum = hasPathSum(root.left, targetSum - root.val);
        boolean rSum = hasPathSum(root.right, targetSum- root.val);

        return lSum || rSum;
    }

   
}",0
"class Solution {
    public static int funnCr(int n,int r){
        long res=1;
        for(int i=0;i<r;i++){
            res=res*(n-i);
            res/=(i+1);
        }
        return (int)res;
    }
    public List<List<Integer>> generate(int n) {
        List<List<Integer>> ans=new ArrayList<>();
        for(int row=0;row<n;row++){
            List<Integer> temp=new ArrayList<>();
            for(int col=0;col<=row;col++){
                temp.add(funnCr(row,col));
            }
            ans.add(temp);
        }
        return ans;
    }
}",0
"class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> row=new ArrayList<>();
        row.add(1);
        for(int i=1;i<=rowIndex;i++){
            row.add((int)((long)row.get(i-1)*(rowIndex-i+1)/i));
        }
        return row;
    }
}",0
"class Solution {
    /*************
    TC - O(n)
    SC - O(1)
    ************* */
    public int maxProfit(int[] prices) {
      int minBuy = Integer.MAX_VALUE;
      int profit = 0;

      for(int i=0;i<prices.length;i++){
        minBuy = Math.min(minBuy,prices[i]);
        profit = Math.max(profit,prices[i] - minBuy);
      }
      return profit;
    }
}",0
"class Solution {
    public boolean isPalindrome(String s) {
        int l = 0;
        int r = s.length() - 1;
        while (l < r) {
            while (!(Character.isLetterOrDigit(s.charAt(l))) && (l < r)) {
                l++;
            }
            while (!(Character.isLetterOrDigit(s.charAt(r))) && (l < r)) {
                r--;
            }
            if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) {
                return false;
            }
            l++;
            r--;
        }
        return true;
    }
}",0
"class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;

        for(int num : nums){
            result ^= num;
        }

        return result;
    }
}",0
"/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        
        if(head == null) {
return false;
}

ListNode fast = head;
ListNode slow = head;

do {
if(fast.next == null || fast.next.next == null) {
return false;
}
fast = fast.next.next;
slow = slow.next;
} while(fast != slow);

return true;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack();
        if(root!=null){
            stack.add(root);
        }
        while(!stack.isEmpty()){
           TreeNode tr = stack.pop();
           list.add(tr.val);
           if(tr.right!=null) stack.add(tr.right);
           if(tr.left!=null) stack.add(tr.left);
        }
        return list;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {

        List<Integer> list=new ArrayList<Integer>();
        helper(root,list);
        return list;
        
    }

    public void helper(TreeNode node, List<Integer> list){
        if(node==null)
        return;

        helper(node.left,list);
        helper(node.right,list);
        list.add(node.val);
    }
}",0
"class Solution {
    public String convertToTitle(int c) {
       
        StringBuilder res = new StringBuilder();
        while (c > 0) {
            c--; 
            int ch = c % 26;
            res.insert(0, (char) (ch + 'A')); 
            c /= 26;
        }
        
        return res.toString();

    }
}",0
"import java.util.*;
class Solution {
    public int majorityElement(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<>();
        // List<Integer> l = new ArrayList<>();
        int len = nums.length;
        for(int i=0;i<len;i++){
            if(map.containsKey(nums[i])){
                map.put(nums[i],map.get(nums[i])+1);
            }
            else{
                map.put(nums[i],1);
            }
        }
        for(int key : map.keySet()){
            if(map.get(key) > len/2){
                return key;
            }
        }
        return -1;
    }
}",0
"class Solution {
    public int titleToNumber(String columnTitle) {
        var columnNumber = 0;

        for (var columnChar : columnTitle.toCharArray()) {
            columnNumber = columnNumber * 26 + 1 + ((int) columnChar - 65);
        }
        return columnNumber;
    }
}",0
"public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ans = 0;   // make variable ans to store the final answer.
        for(int i=0;i<32;i++){   // Iterate the loop 1 to 31 times and in the loop make variable lsb as 0.
            int lsb = 0;
            if(((n>>i)&1)==1){   // go to the every bit and check ith bit in i is set or not if ith bit is set make first to ith bit set(1<<31-i) and store in to the lsb.
                lsb = 1<<31-i;
                ans = ans | lsb;   // every time time set lsb th bit into the ans using or(|) bitwise operator.
            }
        }
        return ans;///  return ans.
    }
}",0
"class Solution {
    public int hammingWeight(int n) {
        int c=0;
        while(n>0){
            if(n%2==1)
                c++;
            n=n/2;
        }
        return c;
    }
}",0
"class Solution {
    public boolean isHappy(int n) {
        
        int sum=0;
        while(n!=1 && n!=4)
        {
           
            while(n>0)
            {
                int rem=n%10;
                sum+=(rem*rem);
                n=n/10;
                
            }
            n=sum;
            sum=0;
        }
        if(n==1)
            return true;
        return false;
    }
}",0
"class Solution {
    public boolean isIsomorphic(String s, String t) {
        //Used to Map Relation of Characters of two Strings
        HashMap<Character, Character> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            //Check for the Key in the Map (Char of S) 
            if (!map.containsKey(s.charAt(i))) {
                //Check for the Corresponding Char Value 
                if (map.containsValue(t.charAt(i))) {
                    return false;
                } else {
                    //Store the Map Relation 
                    map.put(s.charAt(i), t.charAt(i));
                }
            } else {
                //If Other char is positioned then return false
                if (map.get(s.charAt(i)) != t.charAt(i)) {
                    return false;
                }
            }
        }
        return true;
    }
}",0
"/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head){
        if(head==null || head.next==null){
            return head;
        }
        ListNode lft = head;
        ListNode rht = head.next;
        ListNode temp = head.next.next;
        head.next = null;
        while(temp!=null){
            rht.next = lft;

            lft = rht;
            rht = temp;
            temp = temp.next;
        }
        rht.next = lft;
        return rht;
    }
}",0
"class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> uniqueElements = new HashSet<>();

        for (int num : nums) {
            if (uniqueElements.contains(num))
                return true; // Duplicate found
            uniqueElements.add(num);
        }
        return false; // No duplicates found
    }
}",0
"class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
         
        HashMap<Integer,Integer> map = new HashMap<>();
    
        for( int i = 0; i< nums.length; i++){
            if(map.containsKey(nums[i])){            
                if( i - map.get(nums[i]) <= k ){
                    return true;
                }
            } 
            map.put(nums[i] , i);
        }
 
        return false;
        
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;

        // get height of tree:
        int h = 0;
        TreeNode tmp = root;
        while(tmp.left != null) {
            h++;
            tmp = tmp.left;
        }

        // binary search:
        List<Boolean> path = new LinkedList<>();
        for (int i = 0; i < h; i++) {
            TreeNode node = root;

            // (1): step i-times into the correct, known halves
            int j = 0;
            while (j < i) {
                boolean rightHalf = path.get(j);
                node = rightHalf ? node.right : node.left;
                j++;
            }

            // (2)&(3): go right once, then left until the end  
            while(j < h) {
                node = j==i ? node.right : node.left;
                j++;
            }

            boolean rightHalf = node != null;
            path.add(rightHalf);
        }

        // turn boolean path into number (e.g. [true, false, false] = 100 binary = 4 decimal)
        int lastLeaf = 0;
        int len = path.size();
        for (int i = 0; i < len; i++) {
            if (!path.get(i)) continue;

            lastLeaf += (int) Math.pow(2, len-1-i);
        }

        int maxNodes = ((int) Math.pow(2, h+1)) - 1; // e.g. tree of height 3 can have max. 2^4 - 1 nodes.
        int maxLeaf = ((int) Math.pow(2, h)) - 1; // e.g. tree of height 3 can have max. leaf with binary number 2^3 - 1.
        int missingLeaves = maxLeaf - lastLeaf;

        return maxNodes - missingLeaves;
    }
}",0
"class MyStack {

    Queue<Integer> q1 = new LinkedList<>();
    Queue<Integer> q2 = new LinkedList<>();

    public MyStack() {
        
    }
    
    public void push(int x) {
        while(!q1.isEmpty()){
            q2.add(q1.remove());
        }
        q1.add(x);
        while(!q2.isEmpty()){
            q1.add(q2.remove());
        }
    }
    
    public int pop() {
        return q1.remove();
        
    }
    
    public int top() {
        return q1.peek();
        
    }
    
    public boolean empty() {
        return q1.isEmpty() && q2.isEmpty();
        
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */",0
"class Solution {
    public String reverseVowels(String s) {
        char[] cs = s.toCharArray();
        int lc = cs.length - 1,i=0;
        String sv = ""AEIOUaeiou"";
        char ch;

        while(i<lc){
            if(sv.contains(cs[i]+"""") && sv.contains(cs[lc]+"""")){
                ch=cs[i];
                cs[i]=cs[lc];
                cs[lc]=ch;
                lc--;
                i++;
            }
            if(!sv.contains(cs[i]+"""")) i++;
            if(!sv.contains(cs[lc]+"""")) lc--;
        }
        s = new String(cs);
        return s;
    }
}",0
"class Solution {
    public String reverseOnlyLetters(String s) {
        StringBuilder reversed_string = new StringBuilder();
        int j = s.length()-1;
        for(int i = 0; i<s.length(); i++){
            if(Character.isLetter(s.charAt(i))){
                while(!Character.isLetter(s.charAt(j))){
                    j--;
                }
                reversed_string.append(s.charAt(j));
                j--;
            }else{
                reversed_string.append(s.charAt(i));
            }
        }
        return reversed_string.toString();
    }
}",0
"class Solution {
    public void reverseString(char[] s) {
        int i = 0;
        int j = s.length-1;
        while(i<j){
            char temp = s[i];
            s[i++] = s[j];
            s[j--] = temp;
        }
    }
}",0
"class Solution {
    public String reverseStr(String s, int k) {
        char[]arr=s.toCharArray();
        int n=arr.length;
        for(int i=0;i<n;i=i+2*k){
            int start=i;
            int end=Math.min(i+k-1,n-1);

            while(start<end){
                char tmp=arr[start];
                arr[start]=arr[end];
                arr[end]=tmp;
                start++;
                end--;
            }
        }
        return new String(arr);
    }
    
}",0
"public class Solution {
    public String reversePrefix(String word, char ch) {
        int indexFirstOccurrence = word.indexOf(ch);
        if (indexFirstOccurrence == -1) {
            return word;
        } else {
            char[] arr = word.toCharArray();
            for (int i = 0; i <= indexFirstOccurrence; i++) {
                arr[i] = word.charAt(indexFirstOccurrence - i);
            }
            return new String(arr);
        }
    }
}",0
"class Solution {
    public boolean isSubstringPresent(String s) {
        StringBuffer sb=new StringBuffer(s);
        sb.reverse();
        String ma=sb.toString();
        for(int i=0;i<s.length()-1;i++)
        {
            String st=s.substring(i,i+2);
            if(ma.indexOf(st)!=-1)
            {
                return true;
            }
        }
        return false;
    }
}",0
"class Solution {
    public boolean isSameAfterReversals(int num) {
    int target=reverse(num);
    return reverse(target)==num;    
    }
    static int reverse(int num)
    {
        int sum=0;
        while(num>0)
        {
            int rem=num%10;
            sum=sum*10+rem;
            num=num/10;
        }
        return sum;
    }
}",0
"class Solution {
    public String reverseWords(String s) {
        StringBuilder sb= new StringBuilder();
        String[] arr= s.split("" "");
        for(int i=0;i<arr.length;i++){
            char[] ch= arr[i].toCharArray();
            int left=0;
            int right= ch.length-1;
            for(left=0, right=ch.length-1;left<right;left++,right--){
                char temp= ch[left];
                ch[left]= ch[right];
                ch[right]= temp;
            }
            sb.append(String.valueOf(ch));
            if(i!=arr.length-1)
                sb.append("" "");
        }
        return sb.toString();
    }
}",0
"class Solution {
    public boolean canBeEqual(int[] target, int[] arr) {

        Arrays.sort(target);
        Arrays.sort(arr);
        for(int i=0; i<target.length; i++){
            if(target[i] != arr[i]){
                return false;
            }
        }
        return true;
    }
}",0
"class MyStack {
    Queue<Integer> q1 = new LinkedList<>();
    Queue<Integer> q2= new LinkedList<>();
    public MyStack() {
        q1 = new LinkedList<>();
        q2 = new LinkedList<>();
    }
    
    public void push(int x) {
        q2.add(x);
        while(!q1.isEmpty()){
            q2.add(q1.remove());
        }
        while(!q2.isEmpty()){
            q1.add(q2.remove());
        }
    }
    
    public int pop() {
        return q1.remove();
    }

    public int top() {
        return q1.peek();
    }
    
    public boolean empty() {
        return q1.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */",0
"class Solution {
    public List<String> summaryRanges(int[] nums) {

        List<String> ans = new ArrayList<>();
        List<List<Integer>> ranges = new ArrayList<>();
        List<Integer> range = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            if (i == 0) {
                range.add(nums[i]);
                continue;
            }
            if (!range.isEmpty()) {
                if (nums[i] == nums[i - 1] + 1) {
                    continue;
                } else {
                    if (!range.contains(nums[i - 1]))
                        range.add(nums[i - 1]);
                    ranges.add(range);
                    range = new ArrayList<>();
                    range.add(nums[i]);
                }
            }
        }
        if (!range.isEmpty()) {
            if (!range.contains(nums[nums.length - 1])) {
                range.add(nums[nums.length - 1]);
            }
            ranges.add(range);
        }
        for (List<Integer> rr : ranges) {
            if (rr.size() == 1) {
                ans.add(rr.get(0).toString());
            } else {
                ans.add(rr.get(0) + ""->"" + rr.get(1));
            }
        }
        return ans;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null ;
        }
        TreeNode left=invertTree(root.left);
        TreeNode right=invertTree(root.right);
        // swap

        if(left==null && right!=null){
            root.left=root.right;
            root.right=null;
        }
        if(right==null && left!=null){
            root.right=root.left;
            root.left=null;
        }
        if(left!=null && right!=null){
            TreeNode righttree=root.right;
            TreeNode lefttree=root.left;
            root.left=righttree;
            root.right=lefttree;
            
        }


        return root;
    }
}",0
"class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0)
            return false;
        while (n % 2 == 0) {
            n /= 2;
        }
        return n == 1;
    }
}",0
"class MyQueue {

    Stack<Integer> s1=new Stack<>();
    Stack<Integer> s2=new Stack<>();

    public MyQueue() {
        s1=new Stack<>();
        s2=new Stack<>();
    }
    
    public void push(int x) {
        s1.add(x);
    }
    
    public int pop() {
        while(s1.size()>1) {
            s2.add(s1.pop());
        }

        int val=s1.pop();

        while(!s2.isEmpty()) {
            s1.add(s2.pop());
        }

        return val;
    }
    
    public int peek() {
        while(s1.size()>1) {
            s2.add(s1.pop());
        }

        int val=s1.pop();
        s2.add(val);

        while(!s2.isEmpty()) {
            s1.add(s2.pop());
        }

        return val;
    }
    
    public boolean empty() {
        return s1.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */",0
"/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        if (head.next != null && head.next.next == null) {
            if (head.val == head.next.val) return true;
            else return false;
        }


        ListNode slow = head;
        ListNode fast = head;

        // Find the mid
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Slow pointer is now in the mid of the linked list
        // Then we will seperate the list from mid
        // 1 2 3 2 1
        ListNode h1 = slow;
        ListNode h2 = slow.next;
        slow.next = null;

        // Reverse the left side of mid
        ListNode ptr1 = head;
        ListNode ptr2 = null;
        ListNode ptr3 = null;

        while(ptr1 != null) {
            ptr2 = ptr1;
            ptr1 = ptr1.next;
            ptr2.next = ptr3;
            ptr3 = ptr2;
        }

        // Now, if the ListNode fast.next is equal to null that means linkedlist is of Odd
        // That means we have to move the ListNode h1 to the next node towards left before checking
        h1 = fast.next == null ? h1.next : h1; // This is just skipping the mid value for odd list

        while (h1 != null && h2 != null) {
            if (h1.val != h2.val) return false;
            h1 = h1.next;
            h2 = h2.next;
        }

        return true;
    }

}",0
"class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length()!=t.length()){
            return false;
        }
        else{
            int count[]=new int[26];

            for(int i =0;i<s.length();i++){
            count[s.charAt(i)-'a']++;
            }

            for(int i =0;i<t.length();i++){
            count[t.charAt(i)-'a']--;
            }

            for(int i =0;i<count.length;i++){
                if(count[i]!=0){
                    return false;
                }
            }
            return true;
        }
        
    }
}",0
"
class Solution {
    List<String> li = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        dfs(root,new StringBuilder());
        return li;
    }

    public void dfs(TreeNode root,StringBuilder tillNow){
        if(root==null){
            return;
        }
        tillNow.append(root.val).append(""->"");
        if(root.left==null && root.right==null){
            tillNow.delete(tillNow.length()-2, tillNow.length());
            li.add(tillNow.toString());
            return;
        }

        dfs(root.left, new StringBuilder(tillNow));
        dfs(root.right, new StringBuilder(tillNow));
    }
}",0
"class Solution {
    public int addDigits(int num) {
        if(num==0){
            return 0;
        }
        if(num%9==0){
            return 9;
        }
        else{
            return num%9;
        }
    }
}",0
"class Solution {
    public boolean isUgly(int n) {
        if(n <= 0)return false;
        while(n%2==0)n/=2;
        if(n==1)return true;
        while(n%3==0)n/=3;
        if(n==1)return true;
        while(n%5==0)n/=5;
        return n==1;
    }
}",0
"class Solution {
    public int missingNumber(int[] nums) {
        int value = 0;
        int expected = 0;
        for (int i = 0; i < nums.length; i++) {
            value = value + nums[i];
        }
        for (int j = 0; j <= nums.length; j++) {
            expected = expected + j;
        }
        return expected - value;
    }
}",0
"/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int start = 1;
        int ends = n;
        int mid = 0 ;
        while(start <= ends) {
            mid = start + (ends - start)/ 2;
            if(isBadVersion(mid) && !isBadVersion(mid -1 )) {
                return mid;
            } else if(isBadVersion(mid) && isBadVersion(mid -1 )) {
                ends = mid - 1;
            } else if(!isBadVersion(mid)){
               start = mid + 1;
            }
        }
        return mid;
    }
}",0
"class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length;
        int l = 0,c = 0;
        for(int i =0;i<n;i++)
        {
            if(nums[i] != 0)
            {
                nums[l] = nums[i];
                l++;
            }
            else
            {
                c++;
            }
        }
        for(int i = 1;i<=c;i++)
        {
            nums[n-i] = 0;
        }
    }
}",0
"class Solution {
    public boolean wordPattern(String pattern, String s) {
        HashMap<Character, String> hm = new HashMap<>();
        HashMap<String, Character> hm2 = new HashMap<>();
        String arr[] = s.split("" "");
        if(pattern.length()!=arr.length){
            return false;
        }
        for(int i = 0; i < pattern.length(); i++){
            if(hm.containsKey(pattern.charAt(i))){
                if(!hm.get(pattern.charAt(i)).equals(arr[i])){
                    return false;
                }
            } else {
                if(hm2.containsKey(arr[i])){
                    return false;
                }
                hm.put(pattern.charAt(i), arr[i]);
                hm2.put(arr[i], pattern.charAt(i));
            }
        }
        return true;
    }
}",0
"/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null)
        { 
            return null;
        }
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
        
    }
}",0
"class Solution {
    public boolean canWinNim(int n) {
        if(n%4==0) return false;
        else return true;
    }
}",0
"class NumArray {
    private int[] prefixSum;

    public NumArray(int[] nums) {
        int n = nums.length;
        prefixSum = new int[n];
        prefixSum[0] = nums[0];
        for (int i = 1; i < n; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i];
        }
    }

    public int sumRange(int left, int right) {
        if (left == 0) {
            return prefixSum[right];
        } else {
            return prefixSum[right] - prefixSum[left - 1];
        }
    }
}
",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution 
{
    int sum = 0;

    public int rangeSumBST(TreeNode root, int low, int high) 
    {
        inorder(root, low, high);
        return sum;
    }

    private void inorder(TreeNode root, int low, int high)
    {
        if (root == null) return;

        inorder(root.left, low, high);
        
        if (root.val >= low && root.val <= high) {
            sum += root.val;
        }
        
        inorder(root.right, low, high);
    }
}",0
"class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        if (ops.length==0) return m*n;

        int row = ops[0][0];
        int column = ops[0][1];

        for (int i=0;i<ops.length;i++)
        {
            row = Math.min(ops[i][0],row);
            column = Math.min(ops[i][1],column);
        }

        return row*column;
    }
}",0
"class Solution {
    public int countOdds(int low, int high) {
        int count=0;
    if(low%2==1 || high%2==1)
    {
        return (high-low)/2+1;
    }
     if(low%2==0 || high%2==0)
    {
        count=(high-low)/2;
    }
    
        return count;
    }
}",0
"class Solution {
    public List<String> cellsInRange(String s) {
        List<String> result = new ArrayList<>();

        char left = s.charAt(0);
        char top = s.charAt(1);

        char right = s.charAt(3);
        char bot = s.charAt(4);
        for (char i = left; i <= right; i++) {
            for (char j = top; j <= bot; j++) {
                result.add(new String(new char[]{i, j}));
            }
        }
        return result;
    }
}",0
"class Solution {
    public int vowelStrings(String[] words, int left, int right) {
        int countVowels = 0;
        String vowels = ""aeiou"";

        for (int i = left; i <= right ; i++) {
            char firstChar = words[i].charAt(0);
            char lastChar = words[i].charAt(words[i].length() - 1);

            if(vowels.indexOf(firstChar) != -1 && vowels.indexOf(lastChar) != -1){
                countVowels++;
            }
        }
        return countVowels;
    }
}",0
"class Solution {
    public boolean isPowerOfThree(int n) {
          if (n <= 0) {
            return false; 
        }
        
        while (n % 3 == 0) {
            n /= 3; 
        }
        
        return n == 1; 
    }
}",0
"public class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            ans[i] = ans[i >> 1] + (i & 1);
        }
        return ans;
    }
}
",0
"class Solution {
    public boolean isPowerOfFour(int n) {
   
    int numBits = 32 - Integer.numberOfLeadingZeros(n);
    if (((n & (1 << numBits-1)) == n)&&numBits%2!=0) {
        return true;
    }
    return false;
}

}",0
"class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        
        if (magazine.length() < ransomNote.length()) {
            return false;
        }

        String[] ran = ransomNote.split("""");
        String res = """";
        for (String val : ran) {
            int index = magazine.indexOf(val);
            if (index >= 0) {
                String s = String.valueOf(magazine.charAt(index));
                magazine = magazine.replaceFirst(s, """");
                res = res.concat(s);
            }
        }

        return res.equals(ransomNote);
        
    }
}",0
"class Solution {
    public int[] intersection(int[] a, int[] b) {
        int n=a.length;
        int m=b.length;
         ArrayList<Integer>list=new ArrayList<>();
         for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                 int ele=a[i];
                 int ele2=b[j];
                if(a[i]==b[j] && (!(list.contains(ele))) && (!(list.contains(ele2)))){
                    list.add(a[i]);
                }

            }
         }
         int arr[]=new int[list.size()];
        for(int k=0;k<list.size();k++){
            arr[k]=list.get(k);
        }
         return arr;    
        
    }
}",0
"class Solution {
    public List<Integer> intersection(int[][] nums) {
       List<Integer> ans = new ArrayList<>();
        
        int[] count  = new int[1001];
        
        for(int[] arr : nums){
            for(int i : arr){
                count[i]++;
            }
        }
        
       for(int i=0;i<count.length;i++){
           if(count[i]==nums.length){
               ans.add(i);
           }
       }
        
        return ans; 
    }
}",0
"class Solution {
    public long minimalKSum(int[] nums, int k) {
        TreeSet<Integer> set=new TreeSet<>();

        for(int number:nums)
            set.add(number);
        
        long sum=((long)k * (long)(k+1))/ 2;
        int count=0;

        for(Integer i:set){
            if(i>k)
                break;
            else{
                sum-=i;
                count++;
            }
        }
        int i=k+1;

        while(count>0){
            if(!set.contains(i)){
                sum+=i;
                count--;
            }
            i++;
        }
        return sum;
    }
}",0
"import java.util.Arrays;
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        HashMap<Integer, Integer> map= new HashMap<>();
        for(int i: nums1) {
            map.put(i, map.getOrDefault(i,0) + 1);
        }

        List<Integer> list = new ArrayList<>();
        for(int i: nums2) {
            if(map.get(i) != null && map.get(i) > 0){
                list.add(i);
                map.put(i, map.get(i)-1);
            }
        }

        int[] arr = new int[list.size()];
        for(int i=0; i<list.size(); i++){
            arr[i] = list.get(i);
        }

        return arr;
    }
}",0
"class Solution {
    public boolean isPerfectSquare(int num) {
     int start =1;
        int end = num;
        while(start<=end){
           long  mid = start+(end-start)/2;
            
            if(mid*mid==num){
                return true;
            }else if(mid*mid>num){
                end =(int) mid-1;
            }else{
                start = (int)mid+1;
            }
        }
        return false;
    }
}",0
"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return              -1 if num is higher than the picked number
 *                              1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int i=1,j=n;
        while(i<=j){
            int m=i+(-i+j)/2;
            int res=guess(m);
            if(res==0){
                return m;
            }
            else if(res==-1){
                j=m-1;
            }
            else{
                i=m+1;
            }
        }
        return -1;
    }
}",0
"class Solution {
    public int firstUniqChar(String s) {
        int[] abc = new int[26];
        Arrays.fill(abc, 0);
        for (char c : s.toCharArray()) {
            abc[c - 'a'] += 1;
        }
        for (int i = 0; i < s.length(); i++) {
            if (abc[s.charAt(i) - 'a'] == 1) {
                return i;
            }
        }
        return -1;
    }
}",0
"class Solution {
    public char findTheDifference(String s, String t) {
        int result = 0;
        
        // XOR all characters in both strings
        for (char c : s.toCharArray()) {
            result ^= c;
        }
        
        for (char c : t.toCharArray()) {
            result ^= c;
        }
        
        // Convert the final result back to a character
        return (char) result;
    }
}",0
"class Solution {
    public boolean isSubsequence(String s, String t) {
        int i = 0, j = 0;
        while(i < s.length() && j < t.length()){
            if(s.charAt(i) == t.charAt(j)) i++;
            j++;
        }
        return i == s.length();
    }
}",0
"class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
       
        List<String> list=new ArrayList<String>();
       for(int hours=0;hours<=11;hours++)
       {
           for(int min=0;min<60;min++)
           {
               if(Integer.bitCount(hours)+Integer.bitCount(min)==turnedOn)
               {
                    StringBuilder sb=new StringBuilder();
                sb.append(hours).append("":"");
                if(min<10)
                {
                    sb.append(""0"");
                }
                sb.append(min);
               
               list.add(sb.toString());
               }
           }
       } 
       return list;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root==null) return 0;

        int sum=0;
        if(root.left!=null && root.left.left==null && root.left.right==null){
            sum += root.left.val;
        }
        sum += sumOfLeftLeaves(root.left);
        sum += sumOfLeftLeaves(root.right);
        return sum;
    }
}",0
"class Solution {
    public String toHex(int num) {
        StringBuilder ans = new StringBuilder();
        char[] hexDigits = new char[]{'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
        if(num == 0) return ""0"";
        long temp = num;
        if(num<0){
            temp = (1L<<32)+num;
        } 
        while(temp != 0){
            int rem = (int)(temp%(1<<4));
            ans.append(hexDigits[rem]);
            temp = temp >> 4;
        }

        return (ans.reverse()).toString();
    }
}",0
"
        public int longestPalindrome(String s) {
                Set<Character> set = new HashSet<>();
                int count = 0;

                for (int i = 0; i < s.length(); i++) {
                        if (set.contains(s.charAt(i))) {
                                set.remove(s.charAt(i));
                                count++;
                        } else set.add(s.charAt(i));
                }

                int res = count * 2;
                if (res < s.length()) return res + 1;

                return res;
        }
        
        ",0
"class Solution {
    public List<String> fizzBuzz(int n) {
       List<String> res=new ArrayList<>();
        
        for(int i=1;i<=n;i++){
            
            if(i%3==0 && i%5==0){
                res.add(""FizzBuzz"");
                
            }
            else if(i%3==0){
                res.add(""Fizz"");
            }
            else if(i%5==0){
                res.add(""Buzz"");
            }
            else {
                res.add(""""+i);
            }
        }
        return res;
    }
}",0
"class Solution {
    public int thirdMax(int[] nums) {
        int firstDistinct = Integer.MIN_VALUE;
        int secondDistinct = Integer.MIN_VALUE;
        int thirdDistinct = Integer.MIN_VALUE;
        boolean isChanged = false;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] > firstDistinct) {
                firstDistinct = nums[i];
            }
        }
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] > secondDistinct && nums[i] < firstDistinct) {
                secondDistinct = nums[i];
            }
        }
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] >= thirdDistinct && nums[i] < secondDistinct) {
                thirdDistinct = nums[i];
                isChanged = true;
            }
        }
        if(!isChanged) {
            return firstDistinct;
        }
        return thirdDistinct;
    }
}",0
"
class Solution {
    public String addStrings(String num1, String num2) {
        int i=num1.length()-1;
        int j=num2.length()-1;
        int carry=0;
        StringBuilder ans=new StringBuilder();
        while(i>=0||j>=0||carry!=0){
            int val1=i>=0? num1.charAt(i)-'0':0;
            int val2=j>=0? num2.charAt(j)-'0':0;
            i--;
            j--;
            int sum=val1+val2+carry;
            carry=sum/10;
            ans.append(sum%10);
        }
        return ans.reverse().toString();
    }
}",0
"class Solution {
    public int islandPerimeter(int[][] grid) {
        int totalPerimeter = 0;
        for(int row =0;row<grid.length;row++){
            for(int element = 0; element<grid[0].length; element++){
                totalPerimeter+=contribution(row,element,grid);
            }
        }
        return totalPerimeter;
    }


    private static int contribution(int i,int j, int[][] grid){
        if(grid[i][j]==0) return 0;
        // for each direction, 
        // check if neighbour is water,
        // or if it is on border of the grid
        int   up   = ( i==0 || grid[i-1][j] == 0 )? 1 : 0;
        int  down  = (i==grid.length-1 || grid[i+1][j] == 0)? 1:0;
        int  left  = ( j==0 || grid[i][j-1] == 0)? 1:0;
        int right  = (j==grid[0].length-1 || grid[i][j+1] == 0)? 1:0;
        return up+down+left+right;
    }
}",0
"import java.util.StringTokenizer;
class Solution {
    public int countSegments(String s) {
        StringTokenizer st = new StringTokenizer(s);
        int word=0;
        while(st.hasMoreTokens()){
            word++;
            st.nextToken();
        }
        return word;
    }
}",0
"class Solution {
    public int arrangeCoins(int n) {
        int k=0;
        while(n>0){
            k++;
            n=n-k;
        }
        if(n==0){
            return k;
        }
        return k-1;
    }
}",0
"class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> g = new ArrayList<>();
        int[] arr = new int[nums.length+1];
        for(int i=0;i<nums.length;i++){
            arr[nums[i]]=1;
        }
        for(int i=1;i<=nums.length;i++){
            if(arr[i]==0){
                g.add(i);
            }
        }
return g;
    }
}",0
"public class Solution {
    public int findContentChildren(int[] children, int[] cookies) {
        Arrays.sort(children);
        Arrays.sort(cookies);
        
        int child = 0;
int cookie = 0;
        while (child < children.length && cookie < cookies.length) {
            if (cookies[cookie] >= children[child]) {
                child ++;
            }
else{
              cookie++;
            }
        return child;
    }
}",0
"class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        if(timeSeries.length==0)
        return 0;
        int count=0;

        for(int i=1;i<timeSeries.length;i++)
        {
            if(timeSeries[i]-timeSeries[i-1]>=duration)
            {
                count = count + duration;
            }

            else
            {
                count = count+timeSeries[i]-timeSeries[i-1];
            }
        }
        count = count + duration;
        return count;
    }
}",0
"class Solution {
    public boolean repeatedSubstringPattern(String s) {
        String str = s+s;
        return str.substring(1, str.length()-1).contains(s);
    }
}",0
"class Solution {
    public int maximumProduct(int[] nums) {
        Arrays.sort(nums);
         //One of the Three Numbers is the maximum value in the array.

         int a = nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3];
         int b = nums[0] * nums[1] * nums[nums.length - 1];
         return a > b ? a : b;
    }
}",0
"class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1) return false;
        
        int i = 2;
        int sq =(int)Math.sqrt(num);
        int sum=1;
        while(i<=sq){
            if(num%i==0) {
                sum+=i;
                sum+=num/i;
            }
            i++;
        }
        if(sum==num) return true;
        
        return false;
    }
}",0
"class Solution {
    public int[] constructRectangle(int area) 
    {
        int width = (int )Math.sqrt(area);

        while(area % width != 0)
        {
            width--;
        }

        int height = area/width;

    
        return (new int[] {height , width });
    }
}",0
"import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class Solution {
    public String[] findRelativeRanks(int[] score) {
        int n = score.length;
        
        // Create a copy of the score array and sort it in descending order
        int[] sortedScore = Arrays.copyOf(score, n);
        Arrays.sort(sortedScore);
        
        // Create a map to store the rank of each athlete based on their score
        Map<Integer, String> rankMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            if (i == n - 1) {
                rankMap.put(sortedScore[i], ""Gold Medal"");
            } else if (i == n - 2) {
                rankMap.put(sortedScore[i], ""Silver Medal"");
            } else if (i == n - 3) {
                rankMap.put(sortedScore[i], ""Bronze Medal"");
            } else {
                rankMap.put(sortedScore[i], String.valueOf(n - i));
            }
        }
        
        // Assign ranks to each athlete based on the map
        String[] result = new String[n];
        for (int i = 0; i < n; i++) {
            result[i] = rankMap.get(score[i]);
        }
        
        return result;
    }
}
",0
"class Solution {
    public String convertToBase7(int num) {
        if(num==0) return ""0"";
        String ans = """";
        boolean negative = false;
        if(num<0){ 
            negative = true; 
            num=Math.abs(num);
        }
        while(num!=0){
            int mod = num%7;
            ans+=(char)(mod+'0');
            num=num/7;
        }
        ans = reverse(ans);
        if(negative) ans='-'+ans;
        return ans;
    }
    public String reverse(String str){
        String s = """";
        for(int i=str.length()-1;i>=0;i--){
            s+=str.charAt(i);
        }
        return s;
    }
}",0
"class Solution {
    public String licenseKeyFormatting(String word, int k) {

        word = word.replaceAll(""-"","""").toUpperCase();

        for(int index = word.length() -k ; index > 0 ; index = index - k) {
            word = word.substring(0,index ) + ""-"" + word.substring(index);
        }
        return word;
    }
}",0
"class Solution {
    public int findComplement(int num) {
        int n = num;
        int k=0;    //bits
        while(n>0){
            k++;
            n>>=1;
        }
        int mask = (1<<k)-1;
        return num^mask;
    }
}",0
"int k = 0, l = 0;
        for (int i = 0; i <= nums.length-1; i++) {
            if (nums[i] == 1) {
                k++;
                if ((i == nums.length - 1) && k > l)
                    return k;
            } else if (k > l) {
                l = k;
                k = 0;
            } else k = 0;
        }
        return l;",0
"class Solution {
    public int hammingDistance(int x, int y) {
        int z=x^y;
        int c=0;
        while(z!=0)
        {
            c++;
           z=z&(z-1);
        }
        return c;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode insertIntoMaxTree(TreeNode root, int val) {
        if(root==null){
            TreeNode newNode=new TreeNode(val);
            return newNode;
        }
        if(root.val < val) return new TreeNode(val, root, null);
        root.right = insertIntoMaxTree(root.right, val);
        return root;
    }
}",0
"class Solution {
    public int findTilt(TreeNode root) {
        int arr[] = {0};
        helper(root,arr);
        return arr[0];
    }
    public int helper(TreeNode root,int[] arr){
        if(root == null){
            return 0;
        }
        if(root.left == null && root.right == null){
            return root.val;
        }
        int x = helper(root.left,arr);
        int y = helper(root.right,arr);
        arr[0] += Math.abs(x-y);
        return root.val + x + y;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if(root == null) return true;
        if(root.left != null && root.left.val != root.val)
            return false;
        if(root.right != null && root.right.val != root.val)
            return false;
        return (isUnivalTree(root.left) && isUnivalTree(root.right));
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int global_ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        int ans = 0;
        if(root.right != null) ans += get_len( root.right) ;
        if(root.left != null) ans += get_len( root.left);
        
        return Math.max(global_ans, ans);
    }

    public int get_len( TreeNode root){

        int x = 0;
        int y = 0;
        if(root.right != null) x = get_len(root.right);
        if(root.left != null) y = get_len(root.left);

        global_ans = Math.max( global_ans, x+y);

        return Math.max(x , y) + 1;
    }
}",0
"class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> ans = new ArrayList<>();
        if(root == null){
            return ans;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        
        while(!q.isEmpty()){
            int size = q.size();
            long sum = 0l;
            for(int i=0;i<size;i++){
                TreeNode temp = q.poll();
                sum += temp.val;
                if(temp.left != null) q.offer(temp.left);
                if(temp.right != null) q.offer(temp.right);
            }
            double avg = (double)sum / size;
            ans.add(avg);
        }
        return ans;
    }
}",0
"public boolean isCousins(TreeNode root, int x, int y)
    {
        int sum=0;
        Queue<TreeNode> queue=new ArrayDeque<>();
        queue.offer(root);
        while (!queue.isEmpty())
        {
            int count=queue.size();
            for (int i = 0; i < count; i++)
            {
                TreeNode cur=queue.poll();
                if ((cur.left!=null && cur.right!=null) && (cur.left.val==x && cur.right.val==y || cur.left.val==y && cur.right.val==x))
                    return false;
                if (cur.val == x || cur.val == y)
                    sum++;
                if (cur.left!=null)
                    queue.offer(cur.left);
                if (cur.right!=null)
                    queue.offer(cur.right);
            }
            if (sum==2)
                return true;
            sum=0;
        }
        return false;
    }",0
"class Solution {
    public int lastStoneWeight(int[] stones) {
        for(int i=0;i<stones.length-1;i++){
            Arrays.sort(stones);
            int x = stones[stones.length-2];
            int y = stones[stones.length-1];
            if(x==y){
                stones[stones.length-2] = 0;
                stones[stones.length-1] = 0;
            }
            else{
                stones[stones.length-2] = 0;
                stones[stones.length-1] = y-x;
            }
        }
        return stones[stones.length-1];
    }
}",0
"class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
// Basically getting values of next great integer for Nums2 Array
         Stack<Integer> stack=new Stack<>();
        int[]ans=new int[nums1.length];
        int[] temp=new int[nums2.length];
        for (int i =nums2.length-1; i >=0; i--) {
            while (!stack.isEmpty() && stack.peek()<=nums2[i]){
                stack.pop();
            }
            if (i>=0){
                if (!stack.isEmpty()){
                    temp[i]=stack.peek();
                }else {
                    temp[i]=-1;
                }
                stack.push(nums2[i]);
            }
        }
// Since we are required for Nums1 Just map the Elements & return ans
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length ; j++) {
                if (nums1[i]==nums2[j]){
                    ans[i]=temp[j];
                }
            }
        }
        return ans;
    }
}",0
"class Solution {
    public String[] findWords(String[] words) {
        String r1 = ""qwertyuiopQWERTYUIOP"";
        String r2 = ""asdfghjklASDFGHJKL"";
        String r3 = ""zxcvbnmZXCVBNM"";

        List<String> result = new ArrayList<>();
        for (int i = 0; i < words.length; i++) {
            boolean inRow1 = true, inRow2 = true, inRow3 = true;

            for (int j = 0; j < words[i].length(); j++) {
                char c = words[i].charAt(j);

                if (!r1.contains(String.valueOf(c))) {
                    inRow1 = false;
                }

                if (!r2.contains(String.valueOf(c))) {
                    inRow2 = false;
                }

                if (!r3.contains(String.valueOf(c))) {
                    inRow3 = false;
                }
            }

            if (inRow1 || inRow2 || inRow3) {
                result.add(words[i]);
            }
        }
        String[] s = result.toArray(new String[0]);
        return s;
    }
}",0
"public class Solution {
    public int findLUSlength(String a, String b) {
        if (a.equals(b))
            return -1;
        return Math.max(a.length(), b.length());
    }
}",0
"class Solution {
    public int fib(int n) 
    {
    // case 1: if n is 0 return zero
    if(n == 0){
        return 0;
    }
    // Create a list 
     List<Integer> list = new ArrayList<>();
    // Add 0 & 1 as they will help you getting the next 3rd element and from there
    // you can continue to add n-1'th element with n-2'th element
     list.add(0);
     list.add(1);
     // Initializing count with 1 as 0 + 1 = 1 
     int count = 1;
     while(count != n){
         // ex: n = 4 then list will add 2'nd and 3'rd element to generate 4th
         list.add(list.get(list.size()-1)+list.get(list.size()-2));
         count++;
     }
     // Return the last most element of the list
     return list.get(list.size()-1);
    }
}",0
"class Solution {
    public boolean detectCapitalUse(String word) {
        int first_char=0,count=0;
        if(Character.isUpperCase(word.charAt(0)))
           first_char++; 
// if the first character is in uppercase i.e capital then first_count will increase by 1, this will be later used as a condition to check for first character of word whether it is capital or not.
       for(int i=0;i<word.length();i++)
       {
           if(Character.isUpperCase(word.charAt(i)))
           count++;// increases by 1 as it gets characters in uppercase i.e to check if all the letters in word are in capital.
      }
     
       if(count==1&&first_char==1||count==word.length()||count==0)
       {
          return true;
       }
// [count==1&&first_char==1] --> condition for words like ""Google, Leetcode"".
//[count==word.length()] --> condition for words like ""USA,HELLO"".
//[count==0] --> condition for words like ""leetcode, hello"".
        return false;       
       
    }
}",0
"class Solution {
    public String toLowerCase(String s) {

        char [] res = s.toCharArray();
        for( int i=0; i<s.length();i++){
            if(s.charAt(i)>=65 && s.charAt(i) <=90){
                res[i]=(char)(s.charAt(i)+32);
            }
        }
        
        return new String (res);
    }
}",0
"class Solution {
    public int countBinarySubstrings(String s) {
        int ans = 0,c=1,p=0;
        for(int i=1; i<s.length(); i++){
            if (s.charAt(i)==s.charAt(i-1)){
                c++;
            }
            else{
                ans += Math.min(c,p);
                p = c;
                c=1; 
            }
        }
        ans += Math.min(c,p);
        return ans;
    }
}",0
"class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        Set<Character> characterSet = new HashSet<>();
        for (int i = 0; i < jewels.length(); i++) {
            characterSet.add(jewels.charAt(i));
        }

        int result = 0;
        char[] chars = stones.toCharArray();
        for (char aChar : chars) {
            if (characterSet.contains(aChar)) {
                result++;
            }
        }

        return result;
    }
}",0
"class Solution {
    public boolean checkRecord(String s) {
        int count = 0;

        for(char c : s.toCharArray())
           if(c == 'A')
             count++;

        return !s.contains(""LLL"") && count < 2;
    }
}",0
"class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int x=0,y=nums.length-1;
        while(x<y)
        {
            if(nums[x]%2==0)
            {
                x++;
            }
            if(nums[y]%2!=0)
            {
                y--;
            }
            if(nums[x]%2!=0 && nums[y]%2==0 && x<y)
            {
                int t=nums[x];
                nums[x]=nums[y];
                nums[y]=t;
                x++;
                y--;
            }
        }
        return nums;
        
    }
}",0
"class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int low=0,high=letters.length-1;

        while(low<=high)
        {
            int mid=(low+high)/2;
            if(letters[mid]>target)
                high=mid-1;
            else
                low=mid+1;
        }
        if (low==letters.length)
            return letters[0];
        return letters[low];
        
    }
}",0
"class Solution {
    public int calPoints(String[] ops) {
        int[] record= new int[1000];
        int j=0;
        int sum=0;
        for(int i=0; i<ops.length; i++)
        {
            switch(ops[i])
            {
                case ""+"":
                    j++;
                    record[j]=record[j-1]+record[j-2];  
                    break;
                
                case ""C"":
                    record[j]=0;
                    j--;
                    break;
                    
                case ""D"":
                    j++;
                    record[j]=record[j-1]*2;
                    break;
                
                default:
                    j++;
                    record[j]=Integer.valueOf(ops[i]);
                    break;
            }
        }
        for(int k=0; k<record.length;k++)
        {
            sum+=record[k];
        }
        return sum;
    }
}",0
"class Solution {
    public int arrayPairSum(int[] nums) {
        int temp[] = new int[20001];
        for(int i: nums){
            temp[i+10000]++;
        }
        int sum=0 , p=0;
        for(int i=0; i<20001; i++){
            if(temp[i]==0) continue;
            while(temp[i]!=0){
                if(p%2==0){
                    sum+=(i-10000);
                }
                p++;
                temp[i]--;
            }
        }
        return sum;


//    Another solutions 

        // int max = 0;
        // Arrays.sort(nums);
        // for(int i = 0; i<nums.length; i = i+2){
        //     max = max + Math.min(nums[i],nums[i+1]);
        // }
        // return max;
    }
}",0
"class Solution {
    public int pivotIndex(int[] nums) {
        int totalSum=0;
        int leftSum=0;
        
        //loop for calculating totalSum
        for(int i=0;i<nums.length;i++){
            totalSum+=nums[i];
        }
        
        //loop for checking if left sum is equal to right sum(totalSum - leftSum is rightSum)
        // note: we will be excluding the current index element(nums[i]) from  calculation
        for(int i=0;i<nums.length;i++){
            
            if((totalSum-leftSum-nums[i])==leftSum){
                
                return i;
            }
            
            leftSum+=nums[i];
        }
        return -1;
        
    }
}",0
"class Solution {
    public boolean judgeCircle(String moves) {
        char[] arr = new char[moves.length()];
        arr = moves.toCharArray();
        int[] arr2 = {0,0};
        for(int i=0;i<arr.length;i++) {
            if(arr[i]=='U') {
                arr2[1]++;
            }
            else if(arr[i]=='D') {
                arr2[1]--;
            }
            else if(arr[i]=='R') {
                arr2[0]++;
            }
            else if(arr[i]=='L') {
                arr2[0]--;
            }
        }
        int[] ar = {0,0};
        boolean ans=false;
        for(int i=0;i<arr2.length;i++) {
            if(ar[i]==arr2[i]) {
                ans=true;
            }
            else {
                ans=false;
                break;
            }
        }
        return ans;
    }
}",0
"class Solution {
    public int[][] imageSmoother(int[][] arr) {
        int n=arr.length;
        int m=arr[0].length;
        int arr2[][]=new int[n][m];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                int sum=arr[i][j];
                int c=1;
                
                if(j-1>=0){
                    sum=sum+arr[i][j-1];
                    c++;
                    if(i-1>=0){
                        sum=sum+arr[i-1][j-1];
                        c++;
                    }
                }
                if(j+1<m){
                    sum=sum+arr[i][j+1];
                    c++;
                    if(i+1<n){
                        sum=sum+arr[i+1][j+1];
                        c++;
                    }
                }
                if(i-1>=0){
                    sum=sum+arr[i-1][j];
                    c++;
                    if(j+1<m){
                        sum=sum+arr[i-1][j+1];
                        c++;
                    }
                }
                if(i+1<n){
                    sum=sum+arr[i+1][j];
                    c++;
                    if(j-1>=0){
                        sum=sum+arr[i+1][j-1];
                        c++;
                    }
                }
                arr2[i][j]=sum/c;
            }
        }
        return arr2;
    }
}",0
"class Solution {
    public int search(int[] nums, int target) {
        int start = 0; 
        int end = nums.length-1;

        while(start <= end){
            int mid = start+(end - start)/2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                start = mid+1;
            }  else {
                end = mid-1;
            }
        }
        return -1;
    }
}",0
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        TreeNode nodd=null;
        while(true){
            if(root==null){
                break;
            }
            else if(root.val==val){
                nodd=root;
                break;
            }
            else if(val>root.val){
                root=root.right;
            }
            else{
                root=root.left;
            }
        }
        return nodd;
    }
}",0
"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<Integer>> largeGroupPositions(String s) {
        List<List<Integer>> ans = new ArrayList<>();
        int n = s.length(), current = 0, c = s.charAt(0);
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) != c) {
                int x = i - current;
                if (x >= 3) {
                    ans.add(List.of(current, i - 1));
                }
                current = i;
                c = s.charAt(i);
            }
        }
        if (n - current >= 3) {
            ans.add(List.of(current, n - 1));
        }
        return ans;
    }
}",0
"class Solution {

    public boolean isOneBitCharacter(int[] bits) {
        int i = 0;
        int last = bits.length - 1;

        while (i < last) {
            if (bits[i] == 1) {
                i += 2;
            } else {
                i += 1;
            }
        }
        
        return i == last;
    }
}",0
"class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if(rec1[2]<=rec2[0]||rec1[3]<=rec2[1]||rec2[2]<=rec1[0]||rec2[3]<=rec1[1]) return false;
        System.gc();
        return true;
    }
}",0
"class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five=0;
        int ten=0;
        for(int i=0;i<bills.length;i++){
            if(bills[i]==5){
                five+=5;
            }
            else if(bills[i]==10){
                if(five>=5){
                    five-=5;
                    ten+=10;
                }
                else{
                    return false;
                }
            }
            else{
                if(five>=5 && ten>=10){
                    five-=5;
                    ten-=10;
                }
                else if(five>=15){
                    five-=15;
                }
                else {
                    return false;
                }
            }
        }
        return true;
    }
}",0
"class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length==1) return 1;
        int l=0,r=1,maxLength=1;
        while(r<nums.length){
            if(nums[r]>nums[r-1]){
                if(r-l+1>maxLength) maxLength=r-l+1;
            }else{
                l=r;
            }
            r++;
        }
        return maxLength;
    }
}",0
"class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int n = mat.length , m = mat[0].length;
        int arr[][] = new int[r][c];
        if(m*n != r*c) return mat;
        for(int i = 0; i < c*r; i++){
            arr[i/c][i%c] = mat[i/m][i%m];
        }
        return arr;
    }
}",0
"class Solution {
    public int[] numberOfLines(int[] widths, String s) {
        int[] arr = new int[2];
        int x = 1;
        int sum = 0;
        for(char c : s.toCharArray()){
            int char_width = widths[c - 'a'];
            if(char_width + sum > 100){
                x++;
                sum = 0;
            }
            sum += char_width;            
        }
        arr[0] = x;
        arr[1] = sum;
        return arr;
    }
}",0
"class Solution {
    public void frequencyCount(String s,int[] temp){
        for(int i = 0;i<s.length();i++)
            temp[s.charAt(i)-'a']++;
    }
    public boolean check(int[] fre,int[] temp){
        for(int i = 0;i<26;i++){
            if(temp[i]>fre[i])return false;
        }
        return true;
    }
    public int countCharacters(String[] words, String chars) {
        int[] fre = new int[26];
        for(int i = 0;i<chars.length();i++)
            fre[chars.charAt(i)-'a']++;
        int ans = 0;
        for(int i = 0;i<words.length;i++){
            int[] temp = new int[26];
            frequencyCount(words[i],temp);
            if(check(fre,temp))ans+=words[i].length();
        }
        return ans;
    }
}",0
"
class Solution {
    public int dominantIndex(int[] nums) {
        int max = Integer.MIN_VALUE;
        for(int i : nums){
            max = Math.max(i,max);
        }
        int pos = 0;
        for(int x = 0; x < nums.length; x++){
            if (nums[x] == max) pos = x;
            int twice = nums[x] * 2;
            if(twice > max && nums[x] != max) return -1;
        }
        return pos;
    }
}",0
"class Solution {
    public boolean validPalindrome(String s) {
        return util1(s);
    }
    public boolean util1(String str) {
        int i = 0, j = str.length() - 1;
        while (i <= j) {
            if (str.charAt(i) == str.charAt(j)) {
                i++;
                j--;
            } else {
                return func(str, i + 1, j) || func(str, i, j - 1);
            }
        }
        return true;
    }

    public boolean func(String str, int i, int j) {
        while (i <= j) {
            if (str.charAt(i) != str.charAt(j)) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}",0
"class Solution {
    public String[] uncommonFromSentences(String s1, String s2) {
       HashMap<String,Integer> map = new HashMap<>();
        String words1[] = s1.split("" "");
        String words2[] = s2.split("" "");
        for(String word:words1){
            map.put(word,map.getOrDefault(word,0)+1);
        }
        for(String word:words2){
            map.put(word,map.getOrDefault(word,0)+1);
        }
        List<String> result = new ArrayList<>();
        for(String i:map.keySet()){
            if(map.getOrDefault(i,0) == 1){
                result.add(i);
            }
        }
        String[] arr = new String[result.size()];
        for(int i=0;i<arr.length;i++){
            arr[i] = result.get(i);
        }
        return arr;
        
    }
}",0
"class MyHashSet {
    ArrayList<Integer> list;
    public MyHashSet() {
        list = new ArrayList<>();
    }
    
    public void add(int key) {
        if(!list.contains(key)) list.add(key);
    }
    
    public void remove(int key) {
        if(list.contains(key)) list.remove(Integer.valueOf(key));
    }
    
    public boolean contains(int key) {
        return list.contains(key);
    }
}

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 */",0
"class Solution {
    public String removeOuterParentheses(String s) {
        StringBuilder ans=new StringBuilder();
        int count=0;
         for(int i=0; i<s.length(); i++)
        {
            if(s.charAt(i)=='('){
                if(count>0){
                    ans.append(s.charAt(i));
                }
                count++;
            }
            else if(s.charAt(i)==')'){
                count--;
                if(count>0) ans.append(s.charAt(i));
            }
        }
        return ans.toString();
    }
    }",0
"class Solution {
    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {
        
        int aliceCandies = calcTotalCandies(aliceSizes);
        int bobCandies = calcTotalCandies(bobSizes);

        int difference = (aliceCandies-bobCandies)/2;

        for(int i=0; i<aliceSizes.length; i++){
            for(int j=0; j<bobSizes.length; j++){
                if(aliceSizes[i]-bobSizes[j] == difference){
                    return new int[]{aliceSizes[i],bobSizes[j]};
                }
            }
        }

        return null;
    }

    private int calcTotalCandies(int[] arr){
        int candies = 0;
        for(int i=0; i<arr.length; i++){
            candies+=arr[i];
        }
        return candies;
    }
}",0
"class Solution {
    public String convert(String s, int numRows) {
        if(numRows==1)
        {
            return s;
        }
        StringBuilder str = new StringBuilder();
            int n= s.length();
            int k= 2*(numRows -1);
        for(int i=0;i<numRows;i++)
        {
            int index = i;
          while(index < n){
                 str.append(s.charAt(index));
                 if(i!=0 && i!=numRows-1)
                 {
                     int k1 = k-(2*i);
                     int k2 = index + k1;
                  if(k2<n) 
                  {
                      str.append(s.charAt(k2));
                  }   
                 }
              index = index + k;   
          }  
        }     
        return str.toString();
    }
}",0
"class Solution {
    public int reverse(int x) {
        long rev = 0;
        while (x != 0) {
            int n = x % 10;
            rev = rev * 10 + n;
            x = x / 10;
        }
        if (rev > Integer.MAX_VALUE || rev < Integer.MIN_VALUE) {
            return 0;
        }
        else{
            return (int) rev;
        }
    }
}",0
"public class Solution {

    public String longestPalindrome(String s) {
        if (s.length() == 0) {
            return """";
        }
                //Dp array for substring palindrome
        boolean[][] dp = new boolean[s.length()][s.length()];
        int start = 0, end = 0;

        for (int i = 0; i < s.length(); ++i) {
            for (int j = i; j >= 0; --j) {
                boolean startEqEnd = s.charAt(j) == s.charAt(i);

                if (i == j) {
                    //If the same char: 'a' is palindrome
                    dp[i][j] = true;
                } else if (i - j == 1) {
                    //If length 2: 'ab' is palindrome when 'a' == 'b'
                    dp[i][j] = startEqEnd;
                } else if (startEqEnd && dp[i - 1][j + 1]) {
                    //Otherwise: string is palindrome if s(i) == s(j) and substring s(j + 1, i - 1) is palindrome
                    dp[i][j] = true;
                }

                if (dp[i][j] && i - j > end - start ) {
                    end = i;
                    start = j;
                }
            }
        }

        return s.substring(start, end + 1);
    }
}",0
"class Solution {
public int maxArea(int[] height) {
    int max=0,l=0,r=height.length-1,ar;
    while(l<r)
    {
        if(height[r]<height[l])
        {
            ar=(r-l)*(height[r]);
            r--;
        }
        else
        {
            ar=(r-l)*(height[l]);
            l++;
        }
        max=Math.max(max,ar);
        
    }
    return max;
    
}
}",0
"// Top-Down Memoization

// Time complexity: O(m*n)
// Space complexity: O(m*n)

Map<String, Boolean> memo = new HashMap<>();

public boolean isMatch(String s, String p) {
return dfs(s, p, 0, 0);
}

private boolean dfs(String s, String p, int i, int j) {
String key = i + ""_"" + j;

if (memo.containsKey(key))
return memo.get(key);

if (i >= s.length() && j >= p.length())
return true;

if (j >= p.length())
return false;

boolean isMatch = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');

if (j + 1 < p.length() && p.charAt(j + 1) == '*') {
memo.put(key, dfs(s, p, i, j + 2) || (isMatch && dfs(s, p, i + 1, j)));
return memo.get(key);
}

if (isMatch) {
memo.put(key, dfs(s, p, i + 1, j + 1));
return memo.get(key);
}

memo.put(key, false);

return false;
}",0
"class Solution {
    public String intToRoman(int num) {
        String units[]={"""",""I"",""II"",""III"",""IV"",""V"",""VI"",""VII"",""VIII"",""IX""};
        String tens[]={"""",""X"",""XX"",""XXX"",""XL"",""L"",""LX"",""LXX"",""LXXX"",""XC""};
        String hundreds[]={"""",""C"",""CC"",""CCC"",""CD"",""D"",""DC"",""DCC"",""DCCC"",""CM""};
        String thousands[]={"""",""M"",""MM"",""MMM""};
        
        return thousands[num/1000]+
                hundreds[(num%1000)/100]+
                tens[(num%100)/10]+
                units[num%10];
    }
}",0
"class Solution {
    public List<List<Integer>> threeSum(int[] nums) {

        Set<List<Integer>> result = new HashSet<>();
        if(nums.length<=0) return new ArrayList<>();

        Arrays.sort(nums);
        for(int i=0; i<nums.length-2; i++) {
            int j=i+1;
            int k=nums.length-1;
            while(k>j) {
                int sum = nums[j] + nums[k] + nums[i];
                if(sum == 0)
                    result.add(Arrays.asList(nums[i], nums[j++], nums[k--]));
                else if (sum > 0)
                    k--;
                else
                    j++;
            }
        }
        return new ArrayList(result);
    }
}",0
"class Solution {
    public List<String> generateParenthesis(int n) {
        //Approach: using Backtracking 
        List<String> ans = new ArrayList<>();
        backtrack("""", n, n, ans);
        return ans;
    }
    public void backtrack(String s, int open, int close, List<String> ans){
        //base case
        if(open>close) return;
        if(open>0){
            backtrack(s+""("", open-1, close, ans);
        }
        if(close>0){
            backtrack(s+"")"", open, close-1, ans);
        }
        if(open==0 && close==0){
            ans.add(s);
        }
    }
}",0
"public ListNode swapPairs(ListNode head) {
    if(head == null || head.next == null)
        return head;
    ListNode cur = head, pre = null;
    head = cur.next;
    while(cur != null && cur.next!=null) {
        ListNode nxt = cur.next;
        cur.next = nxt.next;
        nxt.next = cur;
        if(pre != null) 
            pre.next = nxt;
        pre = cur;
        cur = cur.next;
    }
    return head;
}",0
"class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        long t = (long) target;
        Set<List<Integer>> set = new HashSet<>();
        Arrays.sort(nums);
        int n = nums.length;
        for(int i=0; i<n-3; i++){
            for(int j=i+1; j<n-2; j++){
                int k = j+1;
                int l = n-1;
                while(k<l){
                    long sum = (long) nums[i]+nums[j]+nums[k]+nums[l];
                    if(sum==t){
                        set.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));
                        k++;
                        l--;
                    }else if(sum<t){
                        k++;
                    }else{
                        l--;
                    }
                }
            }
        }
        return new ArrayList<>(set);
    }
}",0
"class Solution 
{
    String[] keypad={""0"",""1"",""abc"",""def"",""ghi"",""jkl"",""mno"",""pqrs"",""tuv"",""wxyz""};
    public List<String> letterCombinations(String digits) 
    {
        List<String> combinations=new ArrayList<>();
        if(digits.length()==0)
            return combinations;
        StringBuilder helper=new StringBuilder();
        calculate(digits,0,helper,combinations);    
        return combinations;   
    }
    public void calculate(String digits,int index,StringBuilder helper,List<String> combinations)
    {
        if(index==digits.length())
        {
            combinations.add(helper.toString());
            return ;
        }
        int digit=digits.charAt(index)-'0';
        for(int i=0;i<keypad[digit].length();i++)
        {
            helper.append(keypad[digit].charAt(i));
            calculate(digits,index+1,helper,combinations);
            helper.deleteCharAt(helper.length()-1);
        }
    }
}",0
"import java.util.Scanner;

public class Main{
public static void main(String[] args){
Scanner sc=new Scanner(System.in);


String input = sc.next().toString();

StringBuilder ans = new StringBuilder();

for (int i = 0; i <= input.length() - 1; i++) {
if (!(input.charAt(i) == '.')) {
ans.append(input.charAt(i));
}
}

System.out.println(ans.toString());

}
}",0
"import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
StringBuilder sb = new StringBuilder();
int m = sc.nextInt();
List<Integer> list = new ArrayList<>();
for(int i=0; m>0; i++) {
while(m%3!=0) {
m--;
list.add(i);
}
m /= 3;
}
sb.append(list.size()).append(""\n"");
for(Integer i : list) {
sb.append(i).append("" "");
}
System.out.print(sb.toString());
}
}
",0
"import java.util.*;
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), q = sc.nextInt(), ans, x;
        StringBuilder s = new StringBuilder("",,"" + sc.next() + "",,"");
        ans = s.toString().split(""ABC"").length - 1;
        for(int i=0; i<q; i++) {
            x = sc.nextInt();
            if(s.substring(x-1, x+4).indexOf(""ABC"") < 0) {
                s.replace(x+1, x+2, sc.next());
                if(s.substring(x-1, x+4).indexOf(""ABC"") >= 0) ans++;
            } else {
                s.replace(x+1, x+2, sc.next());
                if(s.substring(x-1, x+4).indexOf(""ABC"") < 0) ans--;
            }
            System.out.println(ans);
        }
    }
}",0
"public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        int buildingCount = scanner.nextInt();
        int[] heights = new int[buildingCount + 1];
        
        for (int i = 1; i <= buildingCount; i++) {
            heights[i] = scanner.nextInt();
        }
        
        int[] nearestTaller = new int[buildingCount + 1];
        Stack<Integer> indexStack = new Stack<>();
        
        for (int current = 1; current <= buildingCount; current++) {
            while (!indexStack.isEmpty() && heights[indexStack.peek()] <= heights[current]) {
                indexStack.pop();
            }
            nearestTaller[current] = indexStack.isEmpty() ? 0 : indexStack.peek();
            indexStack.push(current);
        }
        
        int[] countDiff = new int[buildingCount + 2];
        
        for (int j = 1; j <= buildingCount; j++) {
            int start = (nearestTaller[j] == 0) ? 1 : nearestTaller[j];
            int end = j - 1;
            if (start <= end) {
                countDiff[start]++;
                countDiff[end + 1]--;
            }
        }
        
        int[] visibleCount = new int[buildingCount + 1];
        visibleCount[1] = countDiff[1];
        
        for (int i = 2; i <= buildingCount; i++) {
            visibleCount[i] = visibleCount[i - 1] + countDiff[i];
        }
        
        for (int i = 1; i <= buildingCount; i++) {
            System.out.print(visibleCount[i] + (i < buildingCount ? "" "" : ""\n""));
        }
        
        scanner.close();
    }
}",0
"import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int Y = sc.nextInt();
        int ans=365;
        if(Y%4!=0)ans=365;
        if(Y%4==0&&Y%100!=0)ans=366;
        if(Y%100==0)ans=365;
        if(Y%400==0)ans=366;
        System.out.println(ans);
    }
}
",0
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt();
        int[] array = new int[N];
        int[] originalIndex = new int[N];
        
        for (int i = 0; i < N; i++) {
            array[i] = sc.nextInt();
            originalIndex[i] = i + 1; 
        }
        
  
        for (int i = 0; i < N - 1; i++) {
            for (int j = i + 1; j < N; j++) {
                if (array[i] < array[j]) {
                
                    int temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                    
          
                    temp = originalIndex[i];
                    originalIndex[i] = originalIndex[j];
                    originalIndex[j] = temp;
                }
            }
        }
   
        int secondLargestIndex = originalIndex[1];
        
        System.out.println(secondLargestIndex);
    }
}
",0
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.NoSuchElementException;

public class Main {
    static int MOD = 998244353;
    static int INF = Integer.MAX_VALUE/2;

    static void run (final FastScanner scanner, final PrintWriter out) {
        int N = scanner.nextInt();
        long M = scanner.nextLong();
        long[] a = new long[N];
        Arrays.setAll(a, i -> scanner.nextInt());
        long ng = Long.MAX_VALUE / 2, ok = 0;
        while(Math.abs(ok-ng) > 1) {
            long mid = (ok+ng)/2;
            if(ok(a,M,mid)) {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        if (Long.MAX_VALUE/ 4<ok) {
            System.out.println(""infinite"");
        } else {
            System.out.println(ok);
        }
    }

    private static boolean ok(long[] a, long m, long mid) {
        long sum = 0;
        for (int i = 0; i < a.length; i++) {
            sum += Math.min(a[i], mid);
        }
        return sum <= m;
    }

    public static void main(final String[] args) {
        PrintWriter out = new PrintWriter(System.out);
        FastScanner scanner = new FastScanner();
        try {
            run(scanner, out);
        } catch (Throwable e) {
            throw e;
        } finally {
            out.flush();
        }
    }

    static class FastScanner {
        private final InputStream in = System.in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;
        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            }else{
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }
        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}
        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while(isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }
        public long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) {
                throw new NumberFormatException();
            }
            while(true){
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                }else if(b == -1 || !isPrintableChar(b)){
                    return minus ? -n : n;
                }else{
                    throw new NumberFormatException();
                }
                b = readByte();
            }
        }
        public int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }
        public double nextDouble() { return Double.parseDouble(next());}
    }
}
",0
"import java.util.HashMap;
import java.util.Scanner;

public class Main {

public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        char[] s = sc.next().toCharArray();
        
sc.close();

HashMap<Character, Integer> toNum = new HashMap<Character, Integer>();
toNum.put('R', 0);
toNum.put('P', 1);
toNum.put('S', 2);

int[][] dp = new int[n+1][3];
for (int i = 0; i < 3; i++) {
dp[0][i] = 0;
}

        for (int i = 1; i <= n; i++) {
        int win= (toNum.get(s[i-1])+1) %3;
        int draw= (toNum.get(s[i-1])) %3;
        for (int j = 0; j < 3; j++) {
if (j == win) {
dp[i][j] = Math.max(dp[i-1][getJ(j,1)], dp[i-1][getJ(j,-1)]) +1;
}else if(j == draw){
dp[i][j] = Math.max(dp[i-1][getJ(j,1)], dp[i-1][getJ(j,-1)]);
}else {
dp[i][j]=-1;
}
}
}


        int ans=0;
    for (int i = 0; i < 3; i++) {
ans = Math.max(ans, dp[n][i]); 
}
        

System.out.println(ans);
}

private static int getJ(int j, int i) {
int ans = (j+i)%3;
return ans < 0 ? ans +3 : ans;
}

}
",0
"import java.util.*;
import java.io.*;
import java.math.*;
import java.util.stream.*;
import java.util.*;

public class Main {
public static void main(String args[] ) throws Exception {

BufferedReader br = new BufferedReader( new  InputStreamReader( System.in ) ) ;
int N = Integer.valueOf( br.readLine().trim() ) ;
String[] ss = br.readLine().trim().split("" "") ;
int[] arr = new int[N] ; 
for ( int i=0 ; i<N;  i++ ) 
arr[i] = Integer.valueOf( ss[i] )  ;
br.close() ;

int xm = 0 ; 
for ( int v : arr ) 
xm = Math.max ( xm , v ) ; 

int r=0 ; 
while ( true ) {
if ( 1<<r > xm ) break ;
r++;
}

long t =0 ; 
for ( int i=0 ; i<=r ; i++ ) {
int mask = 1<<i ;
int[] dp = new int[2] ;
for ( int v : arr ) {
v = v & mask ;

int[] dp2 = new int[2] ;
if ( v == mask ) {
dp2[1] += dp[0] ;
dp2[0] += dp[1] ;
} else {
dp2[0] += dp[0] ;
dp2[1] += dp[1] ;
}
t += (long)mask * dp2[1] ;
dp2[ (v==mask) ? 1 : 0 ] ++ ;
dp = dp2 ;
}
}
System.out.println( t ) ;
}
}",0
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

            int a=0,b = 0,c =0;
            char q=input.next().charAt(0);
            if (q=='<'){
                ++b;
            }
            else ++a;
         q=input.next().charAt(0);
        if (q=='<'){
            ++c;
        }
        else ++a;
       q=input.next().charAt(0);
        if (q=='<'){
            ++c;
        }
        else ++b;
        //System.out.println(a);
        //System.out.println(b);
        //System.out.println(c);
        if ((a>c && a<b)||(a>b && c>a)){
            System.out.println(""A"");
        }
        if ((b>c && b<a )||(b>a && b<c)){
            System.out.println(""B"");
        }
        if ((c>a && c<b)||(c>b && c<a)){
            System.out.println(""C"");
        }







    }
    }


",0
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int m = scan.nextInt();
        boolean[] ok = new boolean[n];
        for (int i = 0; i < m; i++) {
            int a = scan.nextInt();
            char b = scan.next().charAt(0);
            if (b == 'M') {
                if (ok[a - 1]) System.out.println(""No"");
                else {
                    ok[a - 1] = true;
                    System.out.println(""Yes"");
                }
            } else System.out.println(""No"");
        }
    }
}",0
"import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;

public class Main {
    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    private static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
    private static StringTokenizer st;

    public static void main(String[] args) throws IOException {
        st = new StringTokenizer(reader.readLine());
        int N = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(reader.readLine());
        int MG = Integer.parseInt(st.nextToken());
        boolean[][] adjG = new boolean[N][N];
        for (int i = 0; i < MG; i++) {
            st = new StringTokenizer(reader.readLine());
            int u = Integer.parseInt(st.nextToken()) - 1;
            int v = Integer.parseInt(st.nextToken()) - 1;
            adjG[u][v] = true;
            adjG[v][u] = true;
        }
        st = new StringTokenizer(reader.readLine());
        int MH = Integer.parseInt(st.nextToken());
        boolean[][] adjH = new boolean[N][N];
        for (int i = 0; i < MH; i++) {
            st = new StringTokenizer(reader.readLine());
            int u = Integer.parseInt(st.nextToken()) - 1;
            int v = Integer.parseInt(st.nextToken()) - 1;
            adjH[u][v] = true;
            adjH[v][u] = true;
        }
        int[][] A = new int[N][N];
        for (int i = 0; i < N - 1; i++) {
            st = new StringTokenizer(reader.readLine());
            for (int j = i + 1; j < N; j++) {
                A[i][j] = Integer.parseInt(st.nextToken());
                A[j][i] = A[i][j];
            }
        }
        int[] indeces = new int[N];
        for (int i = 0; i < N; i++) {
            indeces[i] = i;
        }
        List<List<Integer>> permutations = Permutations.permutationList(indeces);
        int result = Integer.MAX_VALUE;
        for (List<Integer> permutation : permutations) {
            int counter = 0;
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    if (adjG[permutation.get(i)][permutation.get(j)] != adjH[i][j]) {
                        counter += A[i][j];
                    }
                }
            }
            result = Math.min(result, counter);
        }
        writer.write(Integer.toString(result));
        writer.newLine();
        writer.flush();
    }

    static class Permutations {
        public static List<List<Integer>> permutationList(int[] elements) {
            int n = elements.length;
            List<List<Integer>> result = new ArrayList<>();
            int[] indexes = new int[n];

            result.add(copyArray(elements));

            int i = 0;
            while (i < n) {
                if (indexes[i] < i) {
                    swap(elements, i % 2 == 0 ?  0: indexes[i], i);
                    result.add(copyArray(elements));
                    indexes[i]++;
                    i = 0;
                }
                else {
                    indexes[i] = 0;
                    i++;
                }
            }
            return result;
        }

        private static void swap(int[] input, int a, int b) {
            int tmp = input[a];
            input[a] = input[b];
            input[b] = tmp;
        }

        private static List<Integer> copyArray(int[] input) {
            List<Integer> result = new ArrayList<>();
            for (int j : input) {
                result.add(j);
            }
            return result;
        }
    }
}
",0
"import java.util.*;

public class Main{
  public static void main(String[]args){
    
  
    Scanner sc = new Scanner(System.in);
    int l = sc.nextInt();
    int r = sc.nextInt();
    
    if((l==0 && r==0) || (l==1 && r==1)){
      System.out.println(""Invalid"");
    }else  if(l==1 && r==0){
      System.out.println(""Yes"");
    }else  if(r==1 && l==0){
      System.out.println(""No"");
    }
  }
}",0
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[][] arr = new int[N+1][];

        for (int i = 1; i <= N; i++) {
            arr[i] = new int[i+1];
            for (int j = 1; j <= i; j++) {
                arr[i][j] = sc.nextInt();
            }
        }

        int r=1;
        for (int i = 1; i <= N; i++) {
            if(r>=i){
                r = arr[r][i];
            }else{
                r = arr[i][r];
            }
        }

        System.out.println(r);
    }
}
",0
"import java.util.Scanner;
/**
 * C_Word_Ladder
 */
public class Main {

    public static void main(String[] args) {
        Scanner scn=new Scanner(System.in);
        String s=scn.nextLine();
        String t=scn.nextLine();
        if(s.equals(t)){
            System.err.println(0);
        }
        int count=0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)!=t.charAt(i)){
                count++;
                // System.out.println(s.substring(0, i) + t.charAt(i) + s.substring(i+1,s.length()));
            }
        }
        System.out.println(count);
        for(int i=0;i<s.length();i++){
            if((s.charAt(i)!=t.charAt(i)) && t.charAt(i)<s.charAt(i)){
                System.out.println(s.substring(0, i) + t.charAt(i) + s.substring(i+1,s.length()));
                s=s.substring(0, i) + t.charAt(i) + s.substring(i+1,s.length());
            }
        }
        for(int i=s.length()-1;i>=0;i--){
            if((s.charAt(i)!=t.charAt(i)) && t.charAt(i)>s.charAt(i)){
                System.out.println(s.substring(0, i) + t.charAt(i) + s.substring(i+1,s.length()));
                s=s.substring(0, i) + t.charAt(i) + s.substring(i+1,s.length());
            }
        }
    }
}",0
"//package AtCoder.ABC369;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) {
        int a= in.NI(); int b = in.NI();
        // abx. b-a=x-b. x=2b-a
        // bax. a-b=x-a. x=2a-b
        // xab. a-b=x-a. x=2a-b
        // xba. b-a=x-b. x=2b-a
        // axb. x-a=b-x. x=(a+b)/2
        // bxa. x-b=a-x. x=(a+b)/2

        Set<Integer> uni = new HashSet<>();
        uni.add(2*a-b); uni.add(2*b-a);
        if ((a+b)%2==0) uni.add((a+b)/2);
        out.println(uni.size());
        out.close();
    }

    static InputStream inputStream = System.in;
    static OutputStream outputStream = System.out;
    static InputReader in = new InputReader(inputStream);
    static PrintWriter out = new PrintWriter(outputStream);

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int NI() {
            return Integer.parseInt(next());
        }

        public long NL() {
            return Long.parseLong(next());
        }

    }
}",0
"import java.util.Scanner;

public class Main {

        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
        final int N = sc.nextInt();  // ????
        int [] a = new int[N];
        String [] te = new String[N];
        int [] Lte = new int[N];
        int Li = 0;
        String L1 = ""L"";
        int [] Rte = new int[N];
        int Ri = 0;
        String R1 = ""R"";
        
        for(int i=0;i<N;i++) {
                a[i] = sc.nextInt();
            te[i] = sc.next();
            if(L1.equals(te[i])) {
                    Lte[Li] = a[i];
                    Li++;
            }else if(R1.equals(te[i])){
                    Rte[Ri] = a[i];
                    Ri++;
            }
        }
        
        int h = 0;
       for(int i=0;i<Li-1;i++) {
               h += Math.abs(Lte[i]-Lte[i+1]);
       }
       for(int i=0;i<Ri-1;i++) {
               h += Math.abs(Rte[i]-Rte[i+1]);
       }
        System.out.println(h);
        }

}
",0
"import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] ary = new int[n];
        int[] memo = new int[n];
        int[] sa = new int[n];
        long sum = 2 * n -1;
        
        for (int i=0; i<n; i++) {
            ary[i] = sc.nextInt();
        } 
        
        for (int i=1; i<n; i++) {
            memo[i] = ary[i] - ary[i-1];
        } 
        
        for (int i=2; i<n; i++) {
            if(memo[i] == memo[i-1]) sa[i] = sa[i-1] + 1;
        }
        
        for (int i=0; i<n; i++) {
            sum += sa[i];
        } 
        
        System.out.println(sum);
    }
}

",0
"import java.util.*;

public class Main {

    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);
        int pkCount = sc.nextInt();

        StringBuffer buf = new StringBuffer();

        for(int i = 1; i <= pkCount; i++) {
            if(i % 3 == 0) {
                buf.append(""x"");
            } else {
                buf.append(""o"");
            }
        }

        System.out.println(buf.toString());
    }
}
",0
"import java.util.Scanner;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] x = new int[n];
        int[] y = new int[n];

        for (int i = 0; i < n; i++){
            x[i] = sc.nextInt();
            y[i] = sc.nextInt();
            //System.out.println(x[i] + "" "" + y[i]);
        }

        double distance;

        for (int i = 0; i < n; i++){
            double max = 0.0;
            int min = 0;
            for (int j = 0; j < n; j++){
                distance = Math.sqrt(Math.pow(x[i]-x[j], 2) + Math.pow(y[i]-y[j], 2));
                //System.out.println(distance);
                if (max < distance){
                    max = distance;
                    min = j+1;
                    //System.out.println(""?"" + min);
                }
            }
            System.out.println(min);
        }
    }
}",0
"import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;

public class Main {
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
    static String[] in;

    public static void main(String [] args) throws IOException {
        solve();
        pw.flush();
        pw.close();
    }

    public static void solve() throws IOException {
        updateIn();
        int N = Integer.parseInt(in[0]);
        HashMap<Integer, Integer> beans = new HashMap<>();
        for (int i = 0; i < N; i++) {
            updateIn();
            int value = Integer.parseInt(in[0]);
            int color = Integer.parseInt(in[1]);

            int max = Math.min(beans.getOrDefault(color, Integer.MAX_VALUE), value);
            beans.put(color, max);
        }

        ArrayList<Integer> list = new ArrayList<>(beans.values());
        list.sort(Collections.reverseOrder());

        pw.println(list.get(0));
    }

    private static void updateIn() throws IOException {
        in = br.readLine().split("" "");
    }
}",0
"import java.util.Scanner;

public class Main {
public static void main(String[] args) {
// input
Scanner sc = new Scanner(System.in);
int A = Integer.parseInt(sc.next());
int P = Integer.parseInt(sc.next());

System.out.println((int)((3*A + P)/ 2));
}
}",0
"import java.util.*;
 class Restaurant {
String city;
int score;
int n ;
public Restaurant(String city, int score, int n) {
this.city = city;
this.score = score;
this.n = n;
}
}
public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int a = scanner.nextInt();
List<Restaurant> restaurants = new ArrayList<>();
for (int i = 0; i < a; i++) {
String city = scanner.next();
int score = scanner.nextInt();
restaurants.add(new Restaurant(city, score, i + 1));
}
restaurants.sort((r1, r2) -> {
if (!r1.city.equals(r2.city)) {
return r1.city.compareTo(r2.city);
}
return Integer.compare(r2.score, r1.score);
});
for (Restaurant restaurant : restaurants) {
System.out.println(restaurant.n);;
}
}
}",0
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int S = scanner.nextInt();
        int M = scanner.nextInt();
        List<List<Integer>> bulbSwitches = new ArrayList<>();
        for (int i = 0; i < M; i++) {
            int k = scanner.nextInt();
            List<Integer> switches = new ArrayList<>();
            for (int j = 0; j < k; j++) {
                switches.add(scanner.nextInt() - 1);
            }
            bulbSwitches.add(switches);
        }
        int[] bulbParity = new int[M];
        for (int i = 0; i < M; i++) {
            bulbParity[i] = scanner.nextInt();
        }

        scanner.close();
        int result = countValidCombinations(S, M, bulbSwitches, bulbParity);
        System.out.println(result);
    }

    private static int countValidCombinations(int S, int M, List<List<Integer>> bulbSwitches, int[] bulbParity) {
        int validCombinations = 0;

        for (int state = 0; state < (1 << S); state++) {
            boolean allBulbsLit = true;
            for (int i = 0; i < M; i++) {
                int countOn = 0;
                for (int switchIndex : bulbSwitches.get(i)) {
                    if ((state & (1 << switchIndex)) != 0) { 
                        countOn++;
                    }
                }
                if (countOn % 2 != bulbParity[i]) {
                    allBulbsLit = false;
                    break;
                }
            }
            if (allBulbsLit) {
                validCombinations++;
            }
        }

        return validCombinations;
    }
}",0
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class Main {
static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

public static void main(String[] args) throws IOException {

String string = br.readLine();

boolean chk=false;
for(int i=0;i<string.length();i++) {
if(string.charAt(i)=='9') {
chk=true;
break;
}
}
bw.write(chk?""Yes"":""No"");

bw.close();
} // end of main()
} // end of Main class",0
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input = sc.nextInt();
        sc.nextLine();

        int answer = 0;
        for (int i = 0; i < input; i++) {
            String input2 = sc.nextLine();
            String[] input2Arr = input2.split(""\\s"");
            answer += (Integer.parseInt(input2Arr[1]) - Integer.parseInt(input2Arr[0]));
            answer++;
        }

        System.out.println(answer);

        sc.close();
    }
}",0
"import java.io.PrintWriter;
import java.math.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

class Main {
static void solve (Scanner in, PrintWriter out) {

char x = in.next().charAt(0), y = in.next().charAt(0);

if (x == y) out.println(""="");
else if (x > y) out.println("">"");
else out.println(""<"");

}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
PrintWriter out = new PrintWriter(System.out);
solve(in, out);
in.close();
out.close();
}

}
",0
"// LUOGU_RID: 121201327
import java.io.*;

public class Main {

    static Read r = new Read();
    static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));

    public static void main(String[] args) throws Exception {
        int x = r.nextInt();
        int y = r.nextInt();
        int z = r.nextInt();

        System.out.printf(""%d%n"",(x - z) / (z + y));
    }

    private static class Read {
        StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

        public int nextInt() throws Exception {
            st.nextToken();
            return (int) st.nval;
        }

        public String readLine() throws Exception {    
            st.nextToken();
            return st.sval;
        }
    }
}
",0
"import java.util.*;

public class Main{
    public static void main(String[] args){
        String n = new Scanner(System.in).next();
        if(n.charAt(0)== n.charAt(1)
           && n.charAt(1)== n.charAt(2)){
            System.out.println(""Yes"");
        }else if(n.charAt(1)== n.charAt(2)
           && n.charAt(2)== n.charAt(3)){
            System.out.println(""Yes"");
        }else{
            System.out.println(""No"");
        }
    }
}",0
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.Buffer;

/*
 * Solution: 1m
 * Coding: 4m
 * Time: 5m
 *
 * count from start
 */
public class Main {
    public static void main(String[] args) throws IOException {
        //BufferedReader br = new BufferedReader(new FileReader(""atcoder_abc/input.in""));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        long n = Long.parseLong(br.readLine());
        br.close();
        long l0 = 2;
        long l1 = 1;
        long result = 0L;

        if(n == 1){
            System.out.println(l1);
            return;
        } else {
            for(int i = 2;i <= n;i++){
                result = l0 + l1;
                l0 = l1;
                l1 = result;
            }
        }

        System.out.println(result);
    }
}
",0
"import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String s = sc.next();
int a = Integer.valueOf(s.substring(0, 1));
int b = Integer.valueOf(s.substring(1, 2));
int c = Integer.valueOf(s.substring(2, 3));
int d = Integer.valueOf(s.substring(3, 4));

int ans = 0;

for (int i = 0; i < 2; i++) {
for (int j = 0; j < 2; j++) {
for (int k = 0; k < 2; k++) {
if (calc(calc(calc(a, b, i), c, j), d, k) == 7) {
String op1 = i == 0 ? ""+"" : ""-"";
String op2 = j == 0 ? ""+"" : ""-"";
String op3 = k == 0 ? ""+"" : ""-"";
System.out.println(a + op1 + b + op2 + c + op3 + d + ""=7"");
return;
}
}
}
}
}
public static int  calc(int a, int b, int op) {
if (op == 0) {
return a + b;
} else {
return a - b;
}
}
}",0
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner so = new Scanner(System.in);
        int a = so.nextInt();//6
        int b = so.nextInt();//3
        if (a+b < 10) {
            System.out.println(a+b);
        } else {
            System.out.println(""error"");
        }
    }
}
",0
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Set<Character> cs = new HashSet<>();
        char[] cl = sc.next().toCharArray();
        for (char c : cl) {
            cs.add(c);
        }
        System.out.println(cl.length==cs.size()?""yes"":""no"");
    }
}",0
"import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st;

        int n = Integer.parseInt(br.readLine());
        int[] arr = new int[n];

        int sum = 0;
        PriorityQueue<Integer> q = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(br.readLine());
            sum += arr[i];
            if (arr[i] % 10 != 0) {
                q.add(arr[i]);
            }
        }

        if (sum % 10 == 0 && !q.isEmpty()) {
            sum -= q.remove();
        }

        bw.write(sum % 10 == 0 ? ""0"" : (sum + """"));

        bw.flush();
        bw.close();
        br.close();
    }
}",0
"import java.io.*;

public class Main{
    public static void main(String[] args)throws IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter wr=new BufferedWriter(new OutputStreamWriter(System.out));
        String a[]=br.readLine().split(""\\s+"");
        String s=a[0];
        String t=a[1];
        if(s.equals(""AtCoder"")&& t.equals(""Land""))
        wr.write(""Yes\n"");
        else
        wr.write(""No\n"");
        wr.flush();
        wr.close();
        br.close();
    }
}",0
"import java.util.ArrayDeque;
import java.util.Queue;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // person
        int a = sc.nextInt(); // sec
        int[] t = new int[n];
        for(int i=0; i< n; i++){
            t[i] = sc.nextInt();
        }

        int sec = 0;
        for(int i=0; i< n; i++){
            if(sec <= t[i]){
                sec = t[i] + a;
            }else{
                // sec = sec + (t[i-1]-t[i]) + a;
                if(sec > t[i-1]){
                    sec = sec + a;
                }else{
                    sec = sec + (t[i-1]-t[i]) + a;
                }
            }

            System.out.println(sec);
        }
    }
}",0
"import java.util.*;

public class Main {
static int result = 11;
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int m = sc.nextInt();
String[] s = new String[n];
for (int i = 0; i < n; i++) {
s[i] = sc.next();
}
int level = 1;
String x = """";
for (int i = 0; i < m; i++) {
x += ""x"";
}
while (level <= n) {
for (int i = 0; i < n; i++) {
exec(s, s[i], i, level, level);
}
level++;
}
System.out.println(result);
}
static void exec(String[] s,String text, int cur, int curLevel, int level) {
curLevel--;
if(curLevel == 0) {
if(test(text)) {
result = Math.min(result, level);
}
} else {
for (int i = cur + 1; i < s.length - curLevel + 1; i++) {
exec(s, merge(text, s[i]), i, curLevel, level);
}
}
}

static String merge(String a, String b) {
String s = """";
int len = a.length();
for (int i = 0; i < len; i++) {
if (a.charAt(i) == 'o' || b.charAt(i) == 'o') {
s += ""o"";
} else {
s += ""x"";
}
}
return s;
}
static boolean test(String a) {
int len = a.length();
for (int i = 0; i < len; i++) {
if (a.charAt(i) == 'x') {
return false;
}
}
return true;
}
}",0
"import java.util.ArrayList;
import java.util.Scanner;

public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in); 
int n = sc.nextInt();
int m = sc.nextInt();

// H??????ArrayList????
var h = new ArrayList<Integer>();
for(int i =0; i < n; i++) {
h.add(sc.nextInt());
}

int count = 0;
for(int hi : h) {
if(hi <= m) {
++count;
m -= hi;
}else {
break;
}
}
System.out.println(count);
  }
}",0
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class Main{
  
  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    
    String S = br.readLine();
    int upperCount = 0;
    int lowerCount = 0;
    for (int i = 0; i < S.length(); i++){
      char alphabet = S.charAt(i);
      if (Character.isUpperCase(alphabet)){
        upperCount++;
      }else{
        lowerCount++;
      }
    }
    
    String answer = null;
    if (upperCount > lowerCount){
      answer = S.toUpperCase();
    }else{
      answer = S.toLowerCase();
    }
    
    bw.write(answer + ""\n"");
    bw.flush();
    
    
  }
  
  
}",0
"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        List<ArrayList<Character>>grid = new ArrayList<ArrayList<Character>>();
        for (int i=1 ; i<= pow(3,a);i++){
            ArrayList<Character>g = new ArrayList<>();
            for (int j=1 ; j<= pow(3,a);j++){
                g.add('#');


            }
            grid.add(g);
        }

    f(grid,a,0,0);
        for (var g : grid)
        {
          for(var ge : g)
              System.out.print(ge);
            System.out.println("""");

        }


    }
    public static void f(List<ArrayList<Character>>grid,int k , int n , int m)
    {
        if(k<1)return;
        int p = pow(3,k-1);

        f(grid,k-1,0+n,0+m);
        f(grid,k-1,0+n, p+m);
       f(grid,k-1,0+n , 0+2*p+m);
       f(grid , k-1 , 0+p+n , 0+m);
        paintGridWhite(grid,k,0+n,0+m);
       f(grid,k-1 , 0+p+n , 0+2*p+m);
        f(grid,k-1,0+2*p+n,0+m);
        f(grid,k-1,0+2*p+n,0+p+m);
        f(grid,k-1,0+2*p+n , 0+2*p+m);





    }
    public static int pow(int a , int b)
    {
        if(b==0)return 1;
        if(b==1)return a;
        if(b%2 == 0){
            int c = pow(a,b/2);
            return c*c;

        }
        else
            return a*pow(a,b-1);
    }
    public static void paintGridWhite(List<ArrayList<Character>> grid, int k , int p, int q){

        if(k<=0)return;

        int n  = pow(3,k-1);
        int ps = p + n;
        int qs = q + n;
        int pe  = ps + n-1;
        int qe = qs + n-1;
        /*System.out.println(""for ""+p +"" ""+ q);
        System.out.println(ps+"" ""+qs +"" ""+pe+"" ""+qe);*/

        for(int i = ps ; i <= pe; i++){
            for(int j = qs ; j <=qe; j++){
               grid.get(i).set(j,'.');
               // System.out.println(i+"" ""+j);

            }

        }


    }
}
",0
"import java.util.Scanner;

public class Main {
public static void main(String[] args) {
try(Scanner sc = new Scanner(System.in);) {
long n = sc.nextLong();
int m = String.valueOf(n).length();
final long mod = 998244353;
long v = 1;
for(int i = 0; i < m; i++) {
v *= 10;
v %= mod;
}

long inv = f(v - 1, mod - 2, mod);
long u = f(v, n, mod);
u--;
u += mod;
u %= mod;

System.out.println(n % mod * inv % mod * u % mod); 

}
}

static long f(long v, long n, long mod) {
long res = 1;
while(n > 0) {
if((n & 1) > 0) {
res *= v;
res %= mod;
}
v *= v;
v %= mod;
n >>= 1;
}
return res;
}
}

",0
"import java.util.*;
import java.util.Map.Entry;
import java.io.*;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;

public class Main {

        public static void main(String[] args) throws IOException {
                InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);
                BufferedReader in = new BufferedReader(reader);
                Main ins = new Main(in);
                ins.calc();
                ins.showResult();
        }

        static class Node {
                int id;
                int gid = -1;
                int reachNum = -1;
                Node next;
                Map<Integer, Node> prevs;

                Node(int id) {
                        this.id = id;
                        this.prevs = new TreeMap<>();
                        this.next = null;
                }

                int getReachNum() {
                        if (this.reachNum > 0) {
                                return this.reachNum;
                        } else {
                                int nextReachNum = this.next.getReachNum();
                                this.reachNum = nextReachNum + 1;
                                return this.reachNum;
                        }
                }
        }

        PrintWriter writer = new PrintWriter(System.out);
        BufferedReader in;
        int N;
        int[] a;
        Node[] nodes;

        Main(BufferedReader in) throws IOException {
                this.N = Integer.parseInt(in.readLine());
                this.a = new int[N];
                String[] tokens = in.readLine().split("" "");
                for (int i = 0; i < N; ++i) {
                        a[i] = Integer.parseInt(tokens[i]) - 1;
                }
                this.nodes = new Node[N];
                for (int i = 0; i < N; ++i) {
                        this.nodes[i] = new Node(i);
                }
                for (int i = 0; i < N; ++i) {
                        Node from = this.nodes[i];
                        Node to = this.nodes[a[i]];
                        from.next = to;
                        to.prevs.put(from.id, from);
                }
        }

        void mark(Node node, int gid) {
                if (node.gid >= 0) {
                        return;
                }
                node.gid = gid;
                mark(node.next, gid);
        }

        void calc() {
               
                Deque<Node> deque = new ArrayDeque<>();
                for (Node node : nodes) {
                        if (node.prevs.isEmpty()) {
                                deque.add(node);
                        }
                }
                while (!deque.isEmpty()) {
                        Node node = deque.pollFirst();
                        node.next.prevs.remove(node.id);
                        if (node.next.prevs.isEmpty()) {
                                deque.addLast(node.next);
                        }
                }

               
                int gid = 0;
                for (Node node : nodes) {
                        if ((node.gid < 0) && !node.prevs.isEmpty()) {
                                mark(node, gid);
                                ++gid;
                        }
                }
              
                int[] gidCounts = new int[gid];
                Arrays.fill(gidCounts, 0);
                for (Node node : nodes) {
                        if (node.gid >= 0) {
                                gidCounts[node.gid]++;
                        }
                }
         
                for (Node node : nodes) {
                        if (node.gid >= 0) {
                                node.reachNum = gidCounts[node.gid];
                        }
                }
                long result = 0L;
                for (Node node : nodes) {
                        result += (long) node.getReachNum();
                }
                this.writer.println(result);

        }

        void showResult() {
                this.writer.flush();
        }

}",0
"import java.io.*;
import java.util.*;

public class Main{

    public static void main(String[] args){
     

        helper5();
    
    }
    
    public static void helper5() {
        Scanner scan = new Scanner(System.in);
        //int n = scan.nextInt();
        String n = scan.next();
        
        int rice = 0;
        int soup = 0;
        for(int i = 0; i < 3; i++){
            if(n.charAt(i) == 'R')
                rice = i;

            if(n.charAt(i) == 'M')
                soup = i;

        }
       
        if(rice < soup)
            System.out.println(""Yes"");
        else
            System.out.println(""No"");
    }
}",0
"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);

        String s = sc.next();
        String t = sc.next();

        System.out.println(solve(s, t));
    }

    static String solve(String s, String t) {
        boolean yes = false;
        int sl = s.length();
        for(int w=1; w<sl; w++){
            for(int c=0; c<w; c++) {
                StringBuilder tmp = new StringBuilder("""");
                for(int i=c; i<sl; i+=w) {
                    tmp.append(s.charAt(i));
                }
                if(tmp.toString().equals(t)){
                    return ""Yes"";
                }
            }
        }
        return ""No"";
    }
}
",0
"import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int N = sc.nextInt();
int[] A = new int[N+1];
int[] W = new int[N+1];

for(int i=1;i<=N;i++) {
A[i] = sc.nextInt();
}

for(int i=1;i<=N;i++) {
W[i] = sc.nextInt();
}

int max_int[] = new int[N+1];

for(int i=1;i<=N; i++) {

max_int[A[i]] = Math.max(max_int[A[i]],W[i]);
}

int total = 0;
int max = 0;

for(int i=1;i<=N;i++) {
//System.out.print(W[i]+"" "");
total = total + W[i];
}

//System.out.println();
for(int i=1;i<=N;i++) {
//System.out.print(max_int[i]+"" "");
max = max + max_int[i];
}

System.out.println(total-max);
}
}
",0
"import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.IntStream;

public class Main {
public static void main(String[] args) {
var sc = new Scanner(System.in);
var n = sc.nextInt();
var t = sc.nextInt();
var s = sc.next();
var a = IntStream.range(0, n).map(x -> sc.nextInt()).toArray();
sc.close();

var set1 = new TreeSet<Long>();
var set2 = new TreeSet<Long>();
var chars = s.toCharArray();
for (var i = 0; i < n; i++) {
if (chars[i] == '0') {
set1.add((long)a[i]);
} else {
set2.add((long)a[i]);
}
}

var map1 = new TreeMap<Long, Integer>();
var map2 = new TreeMap<Long, Integer>();
for (var v : set1) {
map1.put(v, map1.size() + 1);
}
for (var v : set2) {
map2.put(v, map2.size() + 1);
}

var result = 0L;
for (var v2 : set2) {
var value1 = 0;
var value2 = 0;
var key1 = map1.floorKey(v2);
if (key1 != null) {
value1 = map1.get(key1);
}
var key2 = map1.floorKey(v2 + t * 2L);
if (key2 != null) {
value2 = map1.get(key2);
}
//System.out.printf(""%d %d %d\r\n"", v2, value1, value2);
result += value2 - value1;
}
System.out.println(result);
}
}
",0
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.NoSuchElementException;

public class Main {
    static long MOD = 998244353L;
    static int INF = Integer.MAX_VALUE/2;

    static long modInv(long a, long mod) {
        long x0 = 1;
        long y0 = 0;
        long x1 = 0;
        long y1 = 1;
        long b = mod;
        while ( b != 0 ) {
            long q = a / b;
            long tmp = b;
            b = a % b;
            a = tmp;

            tmp = x1;
            x1 = x0 - q * x1;
            x0 = tmp;

            tmp = y1;
            y1 = y0 - q * y1;
            y0 = tmp;
        }
        return (x0 + mod) % mod;
    }

    static void run (final FastScanner scanner, final PrintWriter out) {
        long N = scanner.nextInt();
        int K = scanner.nextInt();
        long x = 1;
        long p = 2 * modInv(N*N, MOD);
        for (int i = 0; i < K; i++) {
            x = (((x * (1-(p*(N-1+MOD)%MOD))) % MOD
                    + (1-x+MOD)%MOD * p)) % MOD
                    % MOD;
        }
        // 1-x / N-1
        long xx = (1-x+MOD)%MOD * modInv(N-1, MOD) % MOD;
        long sum = (N*(N+1%MOD)%MOD*modInv(2, MOD) - 1 + MOD)%MOD;
        System.out.println((x + sum*xx)%MOD);

        // 153(=33 + 24*2+24*3) / 81
        //System.out.println(pq(17,9, MOD));// 554580198
    }

    public static void main(final String[] args) {
        PrintWriter out = new PrintWriter(System.out);
        FastScanner scanner = new FastScanner();
        try {
            run(scanner, out);
        } catch (Throwable e) {
            throw e;
        } finally {
            out.flush();
        }
    }

    static class FastScanner {
        private final InputStream in = System.in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;
        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            }else{
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }
        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}
        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while(isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }
        public long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) {
                throw new NumberFormatException();
            }
            while(true){
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                }else if(b == -1 || !isPrintableChar(b)){
                    return minus ? -n : n;
                }else{
                    throw new NumberFormatException();
                }
                b = readByte();
            }
        }
        public int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }
        public double nextDouble() { return Double.parseDouble(next());}
    }
}
",0
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
        public static void main(String[] args) throws Exception {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                int n = Integer.parseInt(br.readLine());
                String[] sa = br.readLine().split("" "");
                int[] a = new int[n];
                for (int i = 0; i < n; i++) {
                        a[i] = Integer.parseInt(sa[i]) + 1;
                }
                br.close();

                int[] dp0 = new int[n + 1];
                int[] dp1 = new int[n + 1];
                for (int i = 1; i <= n; i++) {
                        dp0[i] = Integer.MAX_VALUE;
                        dp1[i] = Integer.MAX_VALUE;
                }

                for (int i = 0; i < n; i++) {
                        int idx = 0;

                        idx = Arrays.binarySearch(dp0, a[i]);
                        if (idx < 0) idx = ~idx;
                        dp0[idx] = a[i];

                        idx = Arrays.binarySearch(dp1, a[i]);
                        if (idx < 0) idx = ~idx;
                        dp1[idx] = a[i];

                        if (i == 0) {
                                dp1[1] = 1;
                        } else  {
                                idx = Arrays.binarySearch(dp0, a[i - 1] + 1);
                                if (idx < 0) idx = ~idx;
                                dp1[idx] = Math.min(a[i - 1] + 1, dp1[idx]);
                        }
                }

                int lis = Arrays.binarySearch(dp1, Integer.MAX_VALUE - 1);
                if (lis < 0) {
                        lis = ~lis;
                        lis--;
                }
                System.out.println(lis);
        }
}
",0
"import java.util.Scanner;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String s = sc.next(); 
        int str = Integer.parseInt(s.substring(3, 6));

        if (str == 000 || str == 316 || str > 349){
            System.out.println(""No"");
        }else{
            System.out.println(""Yes"");
        }
        
    }
}",0
"import java.util.Scanner;

public class Main {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int A = sc.nextInt();
    int B = sc.nextInt();

    int[] array = {1, 2, 3};
    int target = 0;
    int count = 0;
    for (int i = 0; i < array.length; i++) {
      if (array[i] == A || array[i] == B) {
        array[i] = 0;
        count++;
      } else {
        target = array[i];
      }
    }
    if (count == 2) {
      System.out.println(target);
    } else {
      System.out.println(-1);
    }

  }
}
",0
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = Integer.parseInt(sc.next());
        int M = Integer.parseInt(sc.next());

        int[] A = new int[N];
        Set<Integer> setA = new HashSet<>();
        int[] B = new int[M];
        List<Integer> C = new ArrayList<>();

        for (int i = 0; i < N; i++) {
            A[i] = Integer.parseInt(sc.next());
            setA.add(A[i]);
        }

        for (int i = 0; i < M; i++) {
            B[i] = Integer.parseInt(sc.next());
        }
        for (int x : A) {
            C.add(x);
        }
        for (int x : B) {
            C.add(x);
        }
        Collections.sort(C);

        for (int i = 0; i < N + M - 1; i++) {
            if (setA.contains(C.get(i)) && setA.contains(C.get(i + 1))) {
                System.out.println(""Yes"");
                return;
            }
        }
        System.out.println(""No"");
    }
}
",0
"import java.util.*;
import java.io.*;
class Main {
  public static Set<Long> set;
  public static void main(String[] args) {
    FastScanner sc = new FastScanner();
    int n = Integer.parseInt(sc.next());
    int t = Integer.parseInt(sc.next());
    int[] col = new int[n];
    int[] row = new int[n];
    int[] cross = new int[2];
    int ans = -1;
    for(int i = 0; i < t; i++) {
      //System.out.println(i);
      int a = Integer.parseInt(sc.next());
      int c = a % n == 0 ? n -1 : a % n -1;
      int r = a % n == 0 ? a / n - 1 : a / n;
      
      int temp = ++col[c];
      if(temp == n) {
        ans = i + 1;
        //System.out.println(""a"");
        break;
      }
      temp = ++row[r];
      if(temp == n) {
        ans = i + 1;
        //System.out.println(""b"");

        break;
      }
      if(c == r) temp = ++cross[0];
      if(temp == n) {
        ans = i + 1;
        //        System.out.println(""c"");

        break;
      }
      if(c + r == n - 1) temp = ++cross[1];
      if(temp == n) {
        if(a % n == 0 && a != n) continue;
        ans = i + 1;
        //        System.out.println(""d"");

        break;
      }
    }
      System.out.print(ans);
  }
}
class FastScanner {
  private final InputStream in = System.in;
  private final byte[] buffer = new byte[1024];
  private int ptr = 0;
  private int buflen = 0;
  private boolean hasNextByte() {
    if (ptr < buflen) {
      return true;
    }else{
      ptr = 0;
      try {
        buflen = in.read(buffer);
      } catch (IOException e) {
        e.printStackTrace();
      }
      if (buflen <= 0) {
        return false;
      }
    }
    return true;
  }
  private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
  private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
  private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
  public boolean hasNext() { skipUnprintable(); return hasNextByte();}
  public String next() {
    if (!hasNext()) throw new NoSuchElementException();
    StringBuilder sb = new StringBuilder();
    int b = readByte();
    while(isPrintableChar(b)) {
      sb.appendCodePoint(b);
      b = readByte();
    }
    return sb.toString();
  }
  public long nextLong() {
    if (!hasNext()) throw new NoSuchElementException();
    long n = 0;
    boolean minus = false;
    int b = readByte();
    if (b == '-') {
      minus = true;
      b = readByte();
    }
    if (b < '0' || '9' < b) {
      throw new NumberFormatException();
    }
    while(true){
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      }else if(b == -1 || !isPrintableChar(b)){
        return minus ? -n : n;
      }else{
        throw new NumberFormatException();
      }
      b = readByte();
    }
  }
}",0
"import java.util.*;

class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String s = sc.next();

Map<Character, Integer> mp = new HashMap<>();
for (int i = 0; i < s.length(); i++) {
if (mp.containsKey(s.charAt(i)) == false) {
mp.put(s.charAt(i), 1);
} else if (mp.containsKey(s.charAt(i)) == true) {
mp.put(s.charAt(i), mp.get(s.charAt(i)) + 1);
}
}

char searchChar = '1';
for (Map.Entry<Character, Integer> v : mp.entrySet()) {
if (v.getValue() == 1) {
searchChar = v.getKey();
}
}

for (int i = 0; i < s.length(); i++) {
if (searchChar == s.charAt(i)) {
System.out.println(i + 1);
System.exit(0);
}
}
}
}

",0
"import java.util.Scanner;
public class Main{
    public static void main(String[]args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[]p = new int[n];
        for(int i=0;i<n;i++){
            p[i] = sc.nextInt();
        }
        int q = sc.nextInt();
        int[]a = new int[q];
        int[]b = new int[q];
        for(int i=0;i<q;i++){
            a[i] = sc.nextInt();
            b[i] = sc.nextInt();
        }

        for(int i=0;i<q;i++){
            int aindex = linearSearch(p, a[i]);
            int bindex = linearSearch(p, b[i]);
            if(aindex<bindex){
                System.out.println(a[i]);
            }else{
                System.out.println(b[i]);
            }
        }
        sc.close();
    }
    public static int linearSearch(int[]array,int value){
        for(int i=0;i<array.length;i++){
            if(array[i]==value){
                return i;
            }
        }
        return -1;
    }

}
",0
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;

public class Main {
    static int MOD = 1000000007;
    static int INF = Integer.MAX_VALUE/2;

    static void run (final FastScanner scanner, final PrintWriter out) {
        int N = scanner.nextInt();
        char[] s = scanner.next().toCharArray();
        int Q = scanner.nextInt();
        int[] henkan = new int[26];
        for (int i = 0; i < 26; i++) {
            henkan[i] = i;
        }
        for (int __ = 0; __ < Q; __++) {
            int from = scanner.next().charAt(0)-'a';
            int to = scanner.next().charAt(0)-'a';
            if (from==to) {
                continue;
            }
            for (int i = 0; i < henkan.length; i++) {
                if (henkan[i]==from) {
                    henkan[i]=to;
                }
            }
        }
        for (char c : s) {
            out.print((char)(henkan[c-'a']+'a'));
        }
        out.println();
    }

    public static void main(final String[] args) {
        PrintWriter out = new PrintWriter(System.out);
        FastScanner scanner = new FastScanner();
        try {
            run(scanner, out);
        } catch (Throwable e) {
            throw e;
        } finally {
            out.flush();
        }
    }

    static class FastScanner {
        private final InputStream in = System.in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;
        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            }else{
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }
        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}
        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while(isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }
        public long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) {
                throw new NumberFormatException();
            }
            while(true){
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                }else if(b == -1 || !isPrintableChar(b)){
                    return minus ? -n : n;
                }else{
                    throw new NumberFormatException();
                }
                b = readByte();
            }
        }
        public int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }
        public double nextDouble() { return Double.parseDouble(next());}
    }
}
",0
"import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner();
        int n = sc.nextInt();
        HashMap<Integer, Integer> counts = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            for (int j = 2; j * j <= x; j++) {
                while (x % (j * j) == 0) {
                    x /= j * j;
                }
            }
            counts.put(x, counts.getOrDefault(x, 0) + 1);
        }
        long ans = 0;
        if (counts.containsKey(0)) {
            long current = counts.get(0);
            ans += n * current - current * (current + 1) / 2;
            counts.remove(0);
        }
        for (int x : counts.values()) {
            ans += (x - 1L) * x / 2;
        }
        System.out.println(ans);
    }
}
class Scanner {
    BufferedReader br;
    StringTokenizer st = new StringTokenizer("""");
    StringBuilder sb = new StringBuilder();
    
    public Scanner() {
        try {
            br = new BufferedReader(new InputStreamReader(System.in));
        } catch (Exception e) {
            
        }
    }
    
    public int nextInt() {
        return Integer.parseInt(next());
    }
    
    public long nextLong() {
        return Long.parseLong(next());
    }
    
    public double nextDouble() {
        return Double.parseDouble(next());
    }
    
    public String next() {
        try {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(br.readLine());
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            return st.nextToken();
        }
    }
    
}",0
"import java.util.*;

public class Main {
     public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in );
        String s = sc.next();
        String w = """";
        StringBuilder sb = new StringBuilder(s);
        sb.indexOf(""|"");
        
        w += sb.substring(0,sb.indexOf(""|""));
        sb.delete(sb.indexOf(""|""), sb.indexOf(""|"")+1);
        w += sb.substring(sb.indexOf(""|"")+1,sb.length());
        System.out.println(w);
    }
}
",0
"import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        long [] a = new long[100];
        int cnt=0;

        while(sc.hasNext()){
            a[cnt] = sc.nextLong();
            cnt++;
        }
        for(int i=cnt-1;i>=0;i--){
            System.out.println(a[i]);
        }
    }
}
",0
"import java.util.*;
import java.io.*;

class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = Integer.parseInt(sc.next());

List<Integer> a = new ArrayList<>();
for (int i = 0; i < n; i++) {
a.add(Integer.parseInt(sc.next()));
}

int m = Integer.parseInt(sc.next());

List<Integer> b = new ArrayList<>();
for (int i = 0; i < m; i++) {
b.add(Integer.parseInt(sc.next()));
}

int l = Integer.parseInt(sc.next());

List<Integer> c = new ArrayList<>();
for (int i = 0; i < l; i++) {
c.add(Integer.parseInt(sc.next()));
}

Set<Integer> st = new HashSet<>();
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
for (int k = 0; k < l; k++) {
st.add(a.get(i) + b.get(j) + c.get(k));
}
}
}

int q = Integer.parseInt(sc.next());

PrintWriter pw = new PrintWriter(System.out);
for (int i = 0; i < q; i++) {
int x = Integer.parseInt(sc.next());
if (st.contains(x)) {
pw.println(""Yes"");
continue;
}
pw.println(""No"");
}
pw.flush();
}
}

",0
" import java.util.HashMap;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        // Map to store the indices of elements
        HashMap<Integer, Integer> map = new HashMap<>();
        
        // Traverse the array
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            
            // If the complement exists in the map, return the indices
            if (map.containsKey(complement)) {
                return new int[] {map.get(complement), i};
            }
            
            // Otherwise, put the current element and its index in the map
            map.put(nums[i], i);
        }
        
        // If no solution is found, return an empty array
        return new int[] {};
    }
}
",1
" /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1, q = l2, curr = dummyHead;
        int carry = 0;
        
        while (p != null || q != null) {
            int x = (p != null) ? p.val : 0;
            int y = (q != null) ? q.val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            curr.next = new ListNode(sum % 10);
            curr = curr.next;
            if (p != null) p = p.next;
            if (q != null) q = q.next;
        }
        
        if (carry > 0) {
            curr.next = new ListNode(carry);
        }
        
        return dummyHead.next;
    }
}
",1
"class Solution {
    public boolean isPalindrome(int x) {
        // If x is negative or ends with a zero (except when x is 0 itself), it can't be a palindrome
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }
        
        int reversed = 0;
        while (x > reversed) {
            reversed = reversed * 10 + x % 10;
            x /= 10;
        }
        
        // For odd-length palindromes, we can disregard the middle digit
        return x == reversed || x == reversed / 10;
    }
}
",1
"import java.util.HashMap;

class Solution {
    public int romanToInt(String s) {
        HashMap<Character, Integer> romanValues = new HashMap<>();
        romanValues.put('I', 1);
        romanValues.put('V', 5);
        romanValues.put('X', 10);
        romanValues.put('L', 50);
        romanValues.put('C', 100);
        romanValues.put('D', 500);
        romanValues.put('M', 1000);

        int total = 0;
        int prevValue = 0;
        
        for (int i = s.length() - 1; i >= 0; i--) {
            int currValue = romanValues.get(s.charAt(i));
            
            // If the value of the current character is less than the previous one,
            // we subtract it. Otherwise, we add it to the total.
            if (currValue < prevValue) {
                total -= currValue;
            } else {
                total += currValue;
            }
            
            prevValue = currValue;
        }
        
        return total;
    }
}
",1
"class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return """";
        }
        
        // We start with the first string as the initial prefix
        String prefix = strs[0];
        
        // Iterate through the remaining strings
        for (int i = 1; i < strs.length; i++) {
            // While the current string does not start with the prefix, remove characters from the prefix
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) {
                    return """";
                }
            }
        }
        
        return prefix;
    }
}
",1
"import java.util.Stack;

class Solution {
    public boolean isValid(String s) {
        if (s == null || s.length() == 0) {
            return true;
        }
        
        Stack<Character> stack = new Stack<>();
        
        for (char ch : s.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else {
                if (stack.isEmpty()) {
                    return false; // No matching opening bracket
                }
                char top = stack.pop();
                if ((ch == ')' && top != '(') || (ch == '}' && top != '{') || (ch == ']' && top != '[')) {
                    return false; // Mismatched brackets
                }
            }
        }
        
        return stack.isEmpty(); // All opening brackets should be closed
    }
}
",1
"/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode(0);
        ListNode current = dummyHead;
        
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        
        // Attach the remaining nodes
        if (list1 != null) {
            current.next = list1;
        } else {
            current.next = list2;
        }
        
        return dummyHead.next;
    }
}
",1
"class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        
        int uniqueCount = 1; // At least the first element is unique
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[uniqueCount] = nums[i];
                uniqueCount++;
            }
        }
        
        return uniqueCount;
    }
}
",1
"class Solution {
    public int removeElement(int[] nums, int val) {
        int k = 0; // Counter for elements not equal to val
        
        // Iterate through the array
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                // If the current element is not equal to val, move it to the next available position
                nums[k] = nums[i];
                k++; // Increment k
            }
        }
        
        return k; // Return the count of elements not equal to val
    }
}
",1
"class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) {
            return 0; // Empty needle, return 0
        }
        
        int n = haystack.length();
        int m = needle.length();
        
        // Iterate through haystack
        for (int i = 0; i <= n - m; i++) {
            int j;
            // Check if needle matches substring of haystack starting at position i
            for (j = 0; j < m; j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    break; // Mismatch found, break inner loop
                }
            }
            if (j == m) {
                return i; // All characters in needle match, return index i
            }
        }
        
        return -1; // Needle not found in haystack
    }
}
",1
"class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid; // Target found
            } else if (nums[mid] < target) {
                left = mid + 1; // Move search to the right half
            } else {
                right = mid - 1; // Move search to the left half
            }
        }
        
        // If the loop exits, target was not found
        // The insertion index would be at 'left'
        return left;
    }
}
",1
"class Solution {
    public int lengthOfLastWord(String s) {
        // Remove trailing spaces
        s = s.trim();
        
        int length = 0;
        
        // Iterate from the end of the string
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == ' ') {
                break; // Found the end of the last word
            }
            length++; // Increment length for each non-space character
        }
        
        return length;
    }
}
",1
"class Solution {
    public int[] plusOne(int[] digits) {
        // Traverse the digits from right to left
        for (int i = digits.length - 1; i >= 0; i--) {
            // Increment the current digit
            digits[i]++;
            // If the digit becomes 10, set it to 0 and continue to the next digit
            if (digits[i] == 10) {
                digits[i] = 0;
            } else {
                // If the digit is less than 10, no need to carry over, return the array
                return digits;
            }
        }
        
        // If all digits are 9, we need to add an extra digit
        int[] result = new int[digits.length + 1];
        result[0] = 1; // Set the most significant digit to 1
        return result;
    }
}
",1
"class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int carry = 0;
        int i = a.length() - 1;
        int j = b.length() - 1;
        
        // Iterate from the least significant digit to the most significant digit
        while (i >= 0 || j >= 0) {
            int sum = carry;
            if (i >= 0) {
                sum += a.charAt(i--) - '0';
            }
            if (j >= 0) {
                sum += b.charAt(j--) - '0';
            }
            sb.insert(0, sum % 2); // Insert the remainder at the beginning of the StringBuilder
            carry = sum / 2; // Update carry for the next iteration
        }
        
        // If there is a carry after processing all digits, append it to the result
        if (carry > 0) {
            sb.insert(0, carry);
        }
        
        return sb.toString();
    }
}
",1
"class Solution {
    public int mySqrt(int x) {
        if (x == 0 || x == 1) {
            return x; // Square root of 0 or 1 is the number itself
        }
        
        long left = 1; // Start with the left boundary as 1
        long right = x; // End with the right boundary as x
        
        while (left <= right) {
            long mid = left + (right - left) / 2; // Calculate the middle value
            
            if (mid * mid == x) {
                return (int) mid; // Found the square root
            } else if (mid * mid < x) {
                left = mid + 1; // Move to the right half
            } else {
                right = mid - 1; // Move to the left half
            }
        }
        
        // If the loop exits, the square root is not found
        // Return the value of 'right', which is the closest integer less than the square root
        return (int) right;
    }
}
",1
"class Solution {
    public int climbStairs(int n) {
        // Base cases
        if (n == 1) {
            return 1; // Only one way to climb if there is only one step
        }
        
        // Create an array to store the number of distinct ways for each step
        int[] dp = new int[n + 1];
        
        // Base cases
        dp[1] = 1;
        dp[2] = 2;
        
        // Calculate the number of distinct ways for each step using dynamic programming
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        // Return the number of distinct ways to climb to the top
        return dp[n];
    }
}
",1
"class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode current = head;
        
        // Traverse the list
        while (current != null && current.next != null) {
            // If current node's value is equal to next node's value
            if (current.val == current.next.val) {
                // Skip the next node
                current.next = current.next.next;
            } else {
                // Move to the next node
                current = current.next;
            }
        }
        
        return head;
    }
}
",1
"class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // Start from the end of nums1 and nums2
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1; // Index for the merged array nums1
        
        // Merge nums1 and nums2 by comparing elements from the end
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        
        // If there are still elements left in nums2, copy them to nums1
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
}
",1
"import java.util.*;

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        
        while (current != null || !stack.isEmpty()) {
            // Traverse left subtree and push nodes onto stack
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            
            // Visit current node
            current = stack.pop();
            result.add(current.val);
            
            // Move to right subtree
            current = current.right;
        }
        
        return result;
    }
}
",1
"class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // If both nodes are null, they are considered the same
        if (p == null && q == null) {
            return true;
        }
        
        // If one of the nodes is null while the other is not, they are not the same
        if (p == null || q == null) {
            return false;
        }
        
        // If values of corresponding nodes are not equal, they are not the same
        if (p.val != q.val) {
            return false;
        }
        
        // Recursively check left and right subtrees
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
",1
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        // Check if the tree is symmetric
        return isMirror(root, root);
    }
    
    private boolean isMirror(TreeNode t1, TreeNode t2) {
        // If both nodes are null, they are considered symmetric
        if (t1 == null && t2 == null) {
            return true;
        }
        
        // If one of the nodes is null while the other is not, they are not symmetric
        if (t1 == null || t2 == null) {
            return false;
        }
        
        // Check if the values of corresponding nodes are equal
        // and if the subtrees are symmetric
        return (t1.val == t2.val)
            && isMirror(t1.left, t2.right)
            && isMirror(t1.right, t2.left);
    }
}
",1
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        // Base case: if the root is null, the depth is 0
        if (root == null) {
            return 0;
        }
        
        // Recursively calculate the maximum depth of the left and right subtrees
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        
        // The maximum depth of the tree is the maximum depth of its left and right subtrees plus 1
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
",1
"class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        // Check if the array is empty
        if (nums == null || nums.length == 0) {
            return null;
        }
        
        // Construct the BST recursively
        return constructBST(nums, 0, nums.length - 1);
    }
    
    private TreeNode constructBST(int[] nums, int left, int right) {
        // Base case: if left index is greater than right index, return null
        if (left > right) {
            return null;
        }
        
        // Find the middle index
        int mid = left + (right - left) / 2;
        
        // Create the root node using the middle element
        TreeNode root = new TreeNode(nums[mid]);
        
        // Recursively construct the left and right subtrees
        root.left = constructBST(nums, left, mid - 1);
        root.right = constructBST(nums, mid + 1, right);
        
        return root;
    }
}
",1
"class Solution {
    public boolean isBalanced(TreeNode root) {
        // If the tree is null, it is considered height-balanced
        if (root == null) {
            return true;
        }
        
        // Check if the left subtree is height-balanced
        boolean leftBalanced = isBalanced(root.left);
        // Check if the right subtree is height-balanced
        boolean rightBalanced = isBalanced(root.right);
        
        // Calculate the height of the left subtree
        int leftHeight = height(root.left);
        // Calculate the height of the right subtree
        int rightHeight = height(root.right);
        
        // Check if the current node is height-balanced and return the result
        return leftBalanced && rightBalanced && Math.abs(leftHeight - rightHeight) <= 1;
    }
    
    private int height(TreeNode root) {
        // Base case: if the root is null, return 0
        if (root == null) {
            return 0;
        }
        
        // Recursively calculate the height of the left and right subtrees
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        
        // Return the height of the current node
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
",1
"import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int minDepth(TreeNode root) {
        // If the root is null, the minimum depth is 0
        if (root == null) {
            return 0;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int minDepth = 0;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            minDepth++;
            
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                
                // Check if the node is a leaf node
                if (node.left == null && node.right == null) {
                    return minDepth;
                }
                
                // Add the children of the current node to the queue
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        
        return minDepth;
    }
}
",1
"class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        // Base case: if the root is null, return false
        if (root == null) {
            return false;
        }
        
        // Check if the current node is a leaf node
        if (root.left == null && root.right == null) {
            // If the targetSum equals the value of the leaf node, return true
            return targetSum == root.val;
        }
        
        // Recursively check if the left or right subtree has a path sum equal to (targetSum - root.val)
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> triangle = new ArrayList<>();
        
        // Base case: if numRows is 0, return an empty list
        if (numRows == 0) {
            return triangle;
        }
        
        // Initialize the first row with a single element 1
        List<Integer> firstRow = new ArrayList<>();
        firstRow.add(1);
        triangle.add(firstRow);
        
        // Iterate through the remaining rows
        for (int rowNum = 1; rowNum < numRows; rowNum++) {
            List<Integer> prevRow = triangle.get(rowNum - 1);
            List<Integer> row = new ArrayList<>();
            
            // The first and last elements of each row are always 1
            row.add(1);
            
            // Calculate the elements between the first and last elements
            for (int j = 1; j < rowNum; j++) {
                row.add(prevRow.get(j - 1) + prevRow.get(j));
            }
            
            // Add the last element of 1 to the row
            row.add(1);
            
            // Add the row to the triangle
            triangle.add(row);
        }
        
        return triangle;
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> row = new ArrayList<>();
        
        // Base case: if rowIndex is 0, return a list containing only 1
        if (rowIndex == 0) {
            row.add(1);
            return row;
        }
        
        // Initialize the first row with two elements: 1, 1
        row.add(1);
        row.add(1);
        
        // Iterate from the second row to the rowIndex-th row
        for (int i = 2; i <= rowIndex; i++) {
            // Create a new row to store the current row's values
            List<Integer> newRow = new ArrayList<>();
            
            // The first and last elements of each row are always 1
            newRow.add(1);
            
            // Calculate the elements between the first and last elements
            for (int j = 1; j < i; j++) {
                newRow.add(row.get(j - 1) + row.get(j));
            }
            
            // Add the last element of 1 to the row
            newRow.add(1);
            
            // Update the current row with the new row
            row = newRow;
        }
        
        return row;
    }
}
",1
"class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int price : prices) {
            // Update the minimum price encountered so far
            minPrice = Math.min(minPrice, price);
            
            // Update the maximum profit if selling at the current price yields a higher profit
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        
        return maxProfit;
    }
}
",1
"class Solution {
    public boolean isPalindrome(String s) {
        // Convert the string to lowercase
        s = s.toLowerCase();
        
        // Remove all non-alphanumeric characters
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                sb.append(c);
            }
        }
        String cleanedString = sb.toString();
        
        // Use two pointers to check if the string is a palindrome
        int left = 0, right = cleanedString.length() - 1;
        while (left < right) {
            if (cleanedString.charAt(left) != cleanedString.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
}
",1
"class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
}
",1
"class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        
        ListNode slow = head;
        ListNode fast = head.next;
        
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return true;
    }
}
",1
"import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preorder(root, result);
        return result;
    }
    
    private void preorder(TreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        result.add(node.val);  // Visit the current node
        preorder(node.left, result);  // Traverse left subtree
        preorder(node.right, result); // Traverse right subtree
    }
}
",1
"import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postorder(root, result);
        return result;
    }
    
    private void postorder(TreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        postorder(node.left, result);  // Traverse left subtree
        postorder(node.right, result); // Traverse right subtree
        result.add(node.val);          // Visit the current node
    }
}
",1
"public class Solution {
    public String convertToTitle(int columnNumber) {
        StringBuilder result = new StringBuilder();

        while (columnNumber > 0) {
            int remainder = (columnNumber - 1) % 26; // Adjust for 1-based indexing
            char digit = (char) (remainder + 'A'); // Convert remainder to character
            result.insert(0, digit); // Insert character at the beginning of the result
            columnNumber = (columnNumber - 1) / 26; // Adjust column number for the next iteration
        }

        return result.toString();
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] inputs = {1, 28, 701};
        for (int input : inputs) {
            System.out.println(""Input: "" + input + "", Output: "" + solution.convertToTitle(input));
        }
    }
}
",1
"public class Solution {
    public int majorityElement(int[] nums) {
        int candidate = nums[0];
        int count = 1;

        for (int i = 1; i < nums.length; i++) {
            if (count == 0) {
                candidate = nums[i];
                count = 1;
            } else if (nums[i] == candidate) {
                count++;
            } else {
                count--;
            }
        }

        return candidate;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[][] inputs = {{3, 2, 3}, {2, 2, 1, 1, 1, 2, 2}};
        for (int[] input : inputs) {
            System.out.println(""Input: "" + Arrays.toString(input) + "", Output: "" + solution.majorityElement(input));
        }
    }
}
",1
"public class Solution {
    public int titleToNumber(String columnTitle) {
        int result = 0;
        int multiplier = 1;

        // Iterate through the characters of the string from right to left
        for (int i = columnTitle.length() - 1; i >= 0; i--) {
            char c = columnTitle.charAt(i);
            int digitValue = c - 'A' + 1; // Numeric value of the current character
            
            // Accumulate the result
            result += digitValue * multiplier;
            multiplier *= 26; // Update the multiplier
        }

        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        String[] inputs = {""A"", ""AB"", ""ZY""};
        for (String input : inputs) {
            System.out.println(""Input: "" + input + "", Output: "" + solution.titleToNumber(input));
        }
    }
}
",1
"public class Solution {
    // Function to reverse the bits of a 32-bit unsigned integer
    public int reverseBits(int n) {
        int result = 0;
        for (int i = 0; i < 32; i++) {
            // Extract the rightmost bit of 'n'
            int bit = (n >> i) & 1;
            // Append the extracted bit to the result after shifting it to the left
            result = (result << 1) | bit;
        }
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] inputs = {43261596, -3};
        for (int input : inputs) {
            System.out.println(""Input: "" + input + "", Output: "" + solution.reverseBits(input));
        }
    }
}
",1
"public class Solution {
    // Function to count the number of set bits in the binary representation of a positive integer
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            // Increment count if the rightmost bit is set
            count += n & 1;
            // Shift n to the right by one bit
            n >>>= 1;
        }
        return count;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] inputs = {11, 128, 2147483645};
        for (int input : inputs) {
            System.out.println(""Input: "" + input + "", Output: "" + solution.hammingWeight(input));
        }
    }
}
",1
"import java.util.HashSet;
import java.util.Set;

public class Solution {
    // Function to determine if a number is a happy number
    public boolean isHappy(int n) {
        Set<Integer> seen = new HashSet<>();
        while (n != 1) {
            int sum = 0;
            while (n > 0) {
                int digit = n % 10;
                sum += digit * digit;
                n /= 10;
            }
            if (seen.contains(sum)) {
                return false; // Detected a cycle
            }
            seen.add(sum);
            n = sum;
        }
        return true;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] inputs = {19, 2};
        for (int input : inputs) {
            System.out.println(""Input: "" + input + "", Output: "" + solution.isHappy(input));
        }
    }
}
",1
"import java.util.HashMap;
import java.util.Map;

public class Solution {
    public boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        
        Map<Character, Character> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char sChar = s.charAt(i);
            char tChar = t.charAt(i);
            // If the mapping already exists
            if (map.containsKey(sChar)) {
                // Check if the mapping is correct
                if (map.get(sChar) != tChar) {
                    return false;
                }
            } else {
                // Check if the character in t is already mapped
                if (map.containsValue(tChar)) {
                    return false;
                }
                // Create a new mapping
                map.put(sChar, tChar);
            }
        }
        
        return true;
    }
}
",1
"class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode reversedHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return reversedHead;
    }
}
",1
"import java.util.HashSet;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                return true;
            }
            set.add(num);
        }
        return false;
    }
}
",1
"import java.util.HashMap;

class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i]) && Math.abs(i - map.get(nums[i])) <= k) {
                return true;
            }
            map.put(nums[i], i);
        }
        return false;
    }
}
",1
"class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if (leftHeight == rightHeight) {
            // Left subtree is a full binary tree
            return (1 << leftHeight) + countNodes(root.right);
        } else {
            // Right subtree is a full binary tree
            return (1 << rightHeight) + countNodes(root.left);
        }
    }
    
    private int height(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.left;
        }
        return height;
    }
}
",1
"import java.util.LinkedList;
import java.util.Queue;

class MyStack {
    private Queue<Integer> queue1;
    private Queue<Integer> queue2;

    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        // Enqueue x into the non-empty queue
        if (!queue1.isEmpty()) {
            queue1.offer(x);
        } else {
            queue2.offer(x);
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        // Dequeue elements from the non-empty queue until only one element remains
        if (!queue1.isEmpty()) {
            while (queue1.size() > 1) {
                queue2.offer(queue1.poll());
            }
            return queue1.poll();
        } else {
            while (queue2.size() > 1) {
                queue1.offer(queue2.poll());
            }
            return queue2.poll();
        }
    }
    
    /** Get the top element. */
    public int top() {
        // Similar to pop() but do not dequeue the last element
        int topElement = 0;
        if (!queue1.isEmpty()) {
            while (queue1.size() > 1) {
                queue2.offer(queue1.poll());
            }
            topElement = queue1.peek();
            queue2.offer(queue1.poll());
        } else {
            while (queue2.size() > 1) {
                queue1.offer(queue2.poll());
            }
            topElement = queue2.peek();
            queue1.offer(queue2.poll());
        }
        return topElement;
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue1.isEmpty() && queue2.isEmpty();
    }
}
",1
"public class Solution {
    public String reverseVowels(String s) {
        char[] chars = s.toCharArray();
        int left = 0, right = s.length() - 1;
        while (left < right) {
            // Move left pointer to the next vowel
            while (left < right && !isVowel(chars[left])) {
                left++;
            }
            // Move right pointer to the previous vowel
            while (left < right && !isVowel(chars[right])) {
                right--;
            }
            // Swap vowels
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            // Move pointers inward
            left++;
            right--;
        }
        return new String(chars);
    }
    
    private boolean isVowel(char c) {
        return ""aeiouAEIOU"".indexOf(c) != -1;
    }
}
",1
"public class Solution {
    public String reverseOnlyLetters(String s) {
        char[] chars = s.toCharArray();
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (!Character.isLetter(chars[left])) {
                left++;
            } else if (!Character.isLetter(chars[right])) {
                right--;
            } else {
                // Swap letters
                char temp = chars[left];
                chars[left] = chars[right];
                chars[right] = temp;
                left++;
                right--;
            }
        }
        return new String(chars);
    }
}
",1
"public class Solution {
    public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        while (left < right) {
            // Swap characters at left and right pointers
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            // Move pointers towards the center
            left++;
            right--;
        }
    }
}
",1
"public class Solution {
    public String reverseStr(String s, int k) {
        char[] arr = s.toCharArray();
        int n = arr.length;
        for (int i = 0; i < n; i += 2 * k) {
            // Calculate the start and end indices for the current segment
            int start = i;
            int end = Math.min(i + k - 1, n - 1); // Ensure end index does not exceed array bounds
            // Reverse the first k characters of the current segment
            reverse(arr, start, end);
        }
        return new String(arr);
    }
    
    private void reverse(char[] arr, int start, int end) {
        while (start < end) {
            char temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
}
",1
"public class Solution {
    public String reversePrefix(String word, char ch) {
        char[] arr = word.toCharArray();
        int n = arr.length;
        int idx = word.indexOf(ch);
        if (idx != -1) {
            reverse(arr, 0, idx);
        }
        return new String(arr);
    }
    
    private void reverse(char[] arr, int start, int end) {
        while (start < end) {
            char temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
}
",1
"class Solution {
    public boolean isSubstringPresent(String s) {
        int n = s.length();
        // Iterate through the string s
        for (int i = 0; i < n - 1; i++) {
            // Check if the reverse of the current pair exists in s
            if (s.indexOf(new StringBuilder(s.substring(i, i + 2)).reverse().toString()) != -1) {
                return true;
            }
        }
        return false;
    }
}
",1
"class Solution {
    public boolean isSameAfterReversals(int num) {
        int reversed1 = reverse(num);
        int reversed2 = reverse(reversed1);
        return reversed2 == num;
    }
    
    // Function to reverse an integer
    private int reverse(int num) {
        int reversed = 0;
        while (num != 0) {
            int digit = num % 10;
            reversed = reversed * 10 + digit;
            num /= 10;
        }
        return reversed;
    }
}
",1
"class Solution {
    public String reverseWords(String s) {
        // Split the string into words
        String[] words = s.split("" "");
        StringBuilder result = new StringBuilder();
        
        // Iterate through each word
        for (String word : words) {
            // Reverse the word
            String reversedWord = reverseString(word);
            // Append the reversed word to the result
            result.append(reversedWord).append("" "");
        }
        
        // Remove the trailing space and return the result
        return result.toString().trim();
    }
    
    // Function to reverse a string
    private String reverseString(String s) {
        char[] chars = s.toCharArray();
        int left = 0, right = s.length() - 1;
        while (left < right) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
        return new String(chars);
    }
}
",1
"import java.util.Arrays;

class Solution {
    public boolean canBeEqual(int[] target, int[] arr) {
        // Sort both arrays
        Arrays.sort(target);
        Arrays.sort(arr);
        
        // Check if both arrays have the same elements
        for (int i = 0; i < target.length; i++) {
            if (target[i] != arr[i]) {
                return false;
            }
        }
        
        return true;
    }
}
",1
"import java.util.LinkedList;
import java.util.Queue;

class MyStack {
    private Queue<Integer> queue1;
    private Queue<Integer> queue2;
    private int top;

    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        queue2.offer(x);
        top = x;
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        int element = queue1.poll();
        if (!queue1.isEmpty()) {
            top = queue1.peek();
        }
        return element;
    }
    
    /** Get the top element. */
    public int top() {
        return top;
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue1.isEmpty();
    }
}
",1
"import java.util.*;

class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> result = new ArrayList<>();
        int n = nums.length;
        if (n == 0) return result;
        
        int start = nums[0];
        int end = nums[0];
        
        for (int i = 1; i < n; i++) {
            if (nums[i] == end + 1) {
                end = nums[i];
            } else {
                result.add(getRange(start, end));
                start = end = nums[i];
            }
        }
        
        result.add(getRange(start, end));
        
        return result;
    }
    
    private String getRange(int start, int end) {
        return (start == end) ? String.valueOf(start) : start + ""->"" + end;
    }
}
",1
"class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        
        // Swap left and right subtrees
        TreeNode temp = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(temp);
        
        return root;
    }
}
",1
"class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0) {
            return false;
        }
        return (n & (n - 1)) == 0;
    }
}
",1
"import java.util.Stack;

class MyQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;

    /** Initialize your data structure here. */
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        stack1.push(x);
    }
    
    /** Removes the element from the front of queue and returns that element. */
    public int pop() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
}
",1
"class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
    }
}

class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        // Step 1: Find the middle of the linked list
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Step 2: Reverse the second half of the linked list
        ListNode secondHalf = reverseLinkedList(slow.next);
        slow.next = null; // Break the link between first and second half

        // Step 3: Compare the first half with the reversed second half
        ListNode p1 = head;
        ListNode p2 = secondHalf;
        while (p2 != null) {
            if (p1.val != p2.val) {
                return false;
            }
            p1 = p1.next;
            p2 = p2.next;
        }
        return true;
    }

    private ListNode reverseLinkedList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
}
",1
"import java.util.HashMap;
import java.util.Map;

class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        // Create a hashmap to store character frequencies
        Map<Character, Integer> charFreq = new HashMap<>();

        // Count the occurrences of characters in string s
        for (char ch : s.toCharArray()) {
            charFreq.put(ch, charFreq.getOrDefault(ch, 0) + 1);
        }

        // Decrement the frequencies based on characters in string t
        for (char ch : t.toCharArray()) {
            if (!charFreq.containsKey(ch)) {
                // If a character in t does not exist in s, it's not an anagram
                return false;
            }
            charFreq.put(ch, charFreq.get(ch) - 1);
            if (charFreq.get(ch) == 0) {
                charFreq.remove(ch); // Remove the character from the map if its frequency becomes zero
            }
        }

        // If all characters in s and t have the same frequency, they are anagrams
        return charFreq.isEmpty();
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<>();
        if (root == null) {
            return paths;
        }
        dfs(root, new StringBuilder(), paths);
        return paths;
    }
    
    private void dfs(TreeNode node, StringBuilder path, List<String> paths) {
        int length = path.length();
        if (node != null) {
            // Append the current node's value to the path
            if (length == 0) {
                path.append(node.val);
            } else {
                path.append(""->"").append(node.val);
            }
            
            // If the current node is a leaf node, add the path to the result
            if (node.left == null && node.right == null) {
                paths.add(path.toString());
            } else {
                // Continue DFS traversal to the left and right subtrees
                dfs(node.left, path, paths);
                dfs(node.right, path, paths);
            }
            
            // Backtrack: remove the current node's value from the path
            path.setLength(length);
        }
    }
}
",1
"class Solution {
    public int addDigits(int num) {
        while (num >= 10) {
            int sum = 0;
            while (num > 0) {
                sum += num % 10; // Add the last digit
                num /= 10; // Remove the last digit
            }
            num = sum; // Update num to the sum of its digits
        }
        return num;
    }
}
",1
"class Solution {
    public boolean isUgly(int n) {
        if (n <= 0) {
            return false;
        }
        
        while (n % 2 == 0) {
            n /= 2;
        }
        while (n % 3 == 0) {
            n /= 3;
        }
        while (n % 5 == 0) {
            n /= 5;
        }
        
        return n == 1;
    }
}
",1
"class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        // Calculate the sum of the first n positive integers
        int sum = n * (n + 1) / 2;
        // Subtract the sum of elements in nums
        for (int num : nums) {
            sum -= num;
        }
        // The remaining sum is the missing number
        return sum;
    }
}
",1
"public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int left = 1;
        int right = n;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (isBadVersion(mid)) {
                right = mid; // The first bad version is in the left half
            } else {
                left = mid + 1; // The first bad version is in the right half
            }
        }
        // At this point, left and right converge to the first bad version
        return left;
    }
}
",1
"public class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0; // Pointer to track the position where non-zero elements should be placed
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                // Swap the current non-zero element with the element at the left pointer position
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++; // Move the left pointer to the next position
            }
        }
    }
}
",1
"import java.util.HashMap;

public class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split("" "");
        if (pattern.length() != words.length) {
            return false;
        }
        
        HashMap<Character, String> charToWord = new HashMap<>();
        HashMap<String, Character> wordToChar = new HashMap<>();
        
        for (int i = 0; i < pattern.length(); i++) {
            char ch = pattern.charAt(i);
            String word = words[i];
            
            if (!charToWord.containsKey(ch)) {
                if (wordToChar.containsKey(word)) {
                    return false; // Pattern and string mismatch
                }
                charToWord.put(ch, word);
                wordToChar.put(word, ch);
            } else {
                if (!charToWord.get(ch).equals(word) || wordToChar.get(word) != ch) {
                    return false; // Pattern and string mismatch
                }
            }
        }
        
        return true;
    }
}
",1
"class ListNode {
    int val;
    ListNode next;
    
    ListNode(int val) {
        this.val = val;
    }

    // Deserialize method to convert string representation to linked list
    public static ListNode deserialize(String s) {
        if (s == null || s.isEmpty()) {
            return null;
        }

        String[] values = s.split("","");
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;

        for (String value : values) {
            current.next = new ListNode(Integer.parseInt(value));
            current = current.next;
        }

        return dummy.next;
    }
}
",1
"public class Solution {
    public boolean canWinNim(int n) {
        return n % 4 != 0;
    }
}",1
"class NumArray {

private int[] nums;

public NumArray(int[] nums) {
    for(int i = 1; i < nums.length; i++)
        nums[i] += nums[i - 1];
    
    this.nums = nums;
}

public int sumRange(int i, int j) {
    if(i == 0)
        return this.nums[j];
    
    return this.nums[j] - this.nums[i - 1];
}
}",1
"class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        return dfs(root, low, high);
    }
    
    private int dfs(TreeNode node, int low, int high) {
        if (node == null) {
            return 0;
        }
        int sum = 0;
        if (node.val >= low && node.val <= high) {
            sum += node.val;
        }
        if (node.val > low) {
            sum += dfs(node.left, low, high);
        }
        if (node.val < high) {
            sum += dfs(node.right, low, high);
        }
        return sum;
    }
}
",1
"class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        int minRow = m;
        int minCol = n;
        for (int[] op : ops) {
            minRow = Math.min(minRow, op[0]);
            minCol = Math.min(minCol, op[1]);
        }
        return minRow * minCol;
    }
}
",1
"class Solution {
    public int countOdds(int low, int high) {
        // If low is even, increment it to make it odd
        if (low % 2 == 0) {
            low++;
        }
        // If high is even, decrement it to make it odd
        if (high % 2 == 0) {
            high--;
        }
        // Calculate the count of odd numbers between low and high
        int count = (high - low) / 2 + 1;
        return count;
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> cellsInRange(String s) {
        List<String> result = new ArrayList<>();
        
        // Parse the input string to extract range boundaries
        int col1 = s.charAt(0) - 'A' + 1;
        int row1 = Integer.parseInt(s.substring(1, 2));
        int col2 = s.charAt(3) - 'A' + 1;
        int row2 = Integer.parseInt(s.substring(4, 5));
        
        // Generate cell strings within the specified range
        for (int i = col1; i <= col2; i++) {
            for (int j = row1; j <= row2; j++) {
                result.add(Character.toString((char) ('A' + i - 1)) + j);
            }
        }
        
        return result;
    }
}
",1
"class Solution {
    public int countVowelStrings(String[] words, int left, int right) {
        int count = 0;
        
        // Define a set of vowels
        String vowels = ""aeiou"";
        
        // Iterate over the words in the specified range
        for (int i = left; i <= right; i++) {
            String word = words[i];
            
            // Check if the word starts and ends with a vowel character
            if (vowels.indexOf(word.charAt(0)) != -1 && vowels.indexOf(word.charAt(word.length() - 1)) != -1) {
                count++;
            }
        }
        
        return count;
    }
}

",1
"public class Solution {
    public boolean isPowerOfThree(int n) {
        if (n <= 0) {
            return false;
        }
        
        while (n % 3 == 0) {
            n /= 3;
        }
        
        return n == 1;
    }
}
",1
"public class Solution {
    public int[] countBits(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i / 2] + (i % 2);
        }
        return dp;
    }
}
",1
"public class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && n % 3 == 1;
    }
}
",1
"import java.util.HashMap;
import java.util.Map;

public class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> map = new HashMap<>();
        
        // Count frequency of characters in magazine
        for (char c : magazine.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        
        // Check if ransomNote can be constructed
        for (char c : ransomNote.toCharArray()) {
            if (!map.containsKey(c) || map.get(c) <= 0) {
                return false; // Cannot construct
            }
            map.put(c, map.get(c) - 1);
        }
        
        return true;
    }
}
",1
"import java.util.*;

class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();
        
        // Add elements of nums1 to set1
        for (int num : nums1) {
            set1.add(num);
        }
        
        // Add elements of nums2 to set2
        for (int num : nums2) {
            set2.add(num);
        }
        
        // Find the intersection of set1 and set2
        set1.retainAll(set2);
        
        // Convert set to array
        int[] intersection = new int[set1.size()];
        int index = 0;
        for (int num : set1) {
            intersection[index++] = num;
        }
        
        return intersection;
    }
}
",1
"import java.util.*;

class Solution {
    public List<Integer> commonElements(int[][] nums) {
        Map<Integer, Integer> countMap = new HashMap<>();
        List<Integer> result = new ArrayList<>();
        
        // Count occurrences of each integer in each array
        for (int[] array : nums) {
            Set<Integer> seen = new HashSet<>();
            for (int num : array) {
                if (!seen.contains(num)) {
                    countMap.put(num, countMap.getOrDefault(num, 0) + 1);
                    seen.add(num);
                }
            }
        }
        
        // Add integers present in each array to the result list
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            if (entry.getValue() == nums.length) {
                result.add(entry.getKey());
            }
        }
        
        // Sort the result list
        Collections.sort(result);
        
        return result;
    }
}
",1
"import java.util.*;

class Solution {
    public int minSumOfK(int[] nums, int k) {
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        
        int sum = Arrays.stream(nums).sum();
        int numToAdd = 1;
        while (k > 0) {
            if (!numSet.contains(numToAdd)) {
                sum += numToAdd;
                k--;
            }
            numToAdd++;
        }
        
        return sum;
    }
}
",1
"import java.util.*;

class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Map<Integer, Integer> freqMap = new HashMap<>();
        List<Integer> intersection = new ArrayList<>();
        
        // Count frequency of elements in nums1
        for (int num : nums1) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }
        
        // Find intersection and update frequency
        for (int num : nums2) {
            if (freqMap.containsKey(num) && freqMap.get(num) > 0) {
                intersection.add(num);
                freqMap.put(num, freqMap.get(num) - 1);
            }
        }
        
        // Convert list to array
        int[] result = new int[intersection.size()];
        for (int i = 0; i < intersection.size(); i++) {
            result[i] = intersection.get(i);
        }
        
        return result;
    }
}
",1
"class Solution {
    public boolean isPerfectSquare(int num) {
        int i = 1;
        while (num > 0) {
            num -= i;
            i += 2;
        }
        return num == 0;
    }
}
",1
"/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return       -1 if num is higher than the picked number
 *               1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1, high = n;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            int result = guess(mid);
            
            if (result == 0) {
                return mid;
            } else if (result < 0) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        
        // Control should never reach here
        return -1;
    }
}
",1
"import java.util.*;

class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> freqMap = new HashMap<>();
        
        // Count frequency of characters
        for (char c : s.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }
        
        // Find the first non-repeating character
        for (int i = 0; i < s.length(); i++) {
            if (freqMap.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        
        return -1;
    }
}
",1
"public class Solution {
    public char findTheDifference(String s, String t) {
        int[] count = new int[26]; // Array to store the count of characters
        
        // Count frequency of characters in s
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        
        // Decrement count for characters in t
        for (char c : t.toCharArray()) {
            count[c - 'a']--;
        }
        
        // Find the extra character in t
        for (int i = 0; i < 26; i++) {
            if (count[i] < 0) {
                return (char) (i + 'a');
            }
        }
        
        return ' '; // Placeholder, won't be reached
    }
}
",1
"public class Solution {
    public boolean isSubsequence(String s, String t) {
        int sIndex = 0; // Pointer for string s
        int tIndex = 0; // Pointer for string t
        
        // Iterate through both strings
        while (sIndex < s.length() && tIndex < t.length()) {
            // If characters match, move pointer for s
            if (s.charAt(sIndex) == t.charAt(tIndex)) {
                sIndex++;
            }
            // Move pointer for t in any case
            tIndex++;
        }
        
        // If we reached the end of s, it is a subsequence
        return sIndex == s.length();
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

public class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> times = new ArrayList<>();
        // Iterate through all possible combinations of hours and minutes
        for (int h = 0; h < 12; h++) {
            for (int m = 0; m < 60; m++) {
                // Count the number of set bits (turned on LEDs) in hours and minutes
                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {
                    // Format the time representation and add it to the list
                    times.add(String.format(""%d:%02d"", h, m));
                }
            }
        }
        return times;
    }
}
",1
"class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        return sumOfLeftLeaves(root, false);
    }
    
    private int sumOfLeftLeaves(TreeNode node, boolean isLeft) {
        if (node == null) return 0;
        if (node.left == null && node.right == null) {
            if (isLeft) {
                return node.val;
            } else {
                return 0;
            }
        }
        return sumOfLeftLeaves(node.left, true) + sumOfLeftLeaves(node.right, false);
    }
}
",1
"public class Solution {
    public String toHex(int num) {
        if (num == 0) return ""0"";
        
        StringBuilder sb = new StringBuilder();
        while (num != 0) {
            int digit = num & 15; // Extract the last 4 bits (equivalent to num % 16)
            sb.append(toHexChar(digit));
            num >>>= 4; // Shift right by 4 bits (equivalent to num / 16)
        }
        
        return sb.reverse().toString();
    }
    
    private char toHexChar(int digit) {
        if (digit < 10) {
            return (char) ('0' + digit);
        } else {
            return (char) ('a' + digit - 10);
        }
    }
}
",1
"import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int longestPalindrome(String s) {
        if (s == null || s.length() == 0) return 0;
        
        // Frequency map to count occurrences of each character
        Map<Character, Integer> freqMap = new HashMap<>();
        
        // Count frequencies of characters
        for (char c : s.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }
        
        int length = 0;
        boolean hasOddCount = false;
        
        // Iterate through the frequency map
        for (int count : freqMap.values()) {
            if (count % 2 == 0) {
                // Even count, add directly to the length
                length += count;
            } else {
                // Odd count, add count - 1 to the length
                length += count - 1;
                hasOddCount = true;
            }
        }
        
        // If there was at least one odd count, add 1 to the length for the center character
        if (hasOddCount) length++;
        
        return length;
    }
}
",1
"public class Solution {
    public List<String> fizzBuzz(int n) {
        List<String> result = new ArrayList<>();
        
        for (int i = 1; i <= n; i++) {
            if (i % 3 == 0 && i % 5 == 0) {
                result.add(""FizzBuzz"");
            } else if (i % 3 == 0) {
                result.add(""Fizz"");
            } else if (i % 5 == 0) {
                result.add(""Buzz"");
            } else {
                result.add(Integer.toString(i));
            }
        }
        
        return result;
    }
}
",1
"import java.util.*;

public class Solution {
    public int thirdMax(int[] nums) {
        TreeSet<Integer> set = new TreeSet<>();
        
        for (int num : nums) {
            set.add(num);
            if (set.size() > 3) {
                set.remove(set.first());
            }
        }
        
        return set.size() < 3 ? set.last() : set.first();
    }
}
",1
"public class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder result = new StringBuilder();
        int carry = 0;
        int i = num1.length() - 1;
        int j = num2.length() - 1;
        
        while (i >= 0 || j >= 0 || carry > 0) {
            int digit1 = i >= 0 ? num1.charAt(i--) - '0' : 0;
            int digit2 = j >= 0 ? num2.charAt(j--) - '0' : 0;
            int sum = digit1 + digit2 + carry;
            result.insert(0, sum % 10);
            carry = sum / 10;
        }
        
        return result.toString();
    }
}
",1
"public class Solution {
    public int islandPerimeter(int[][] grid) {
        int perimeter = 0;
        int rows = grid.length;
        int cols = grid[0].length;

        // Iterate through each cell in the grid
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // Check if the current cell is land
                if (grid[i][j] == 1) {
                    // Check top neighbor
                    if (i == 0 || grid[i - 1][j] == 0) perimeter++;
                    // Check bottom neighbor
                    if (i == rows - 1 || grid[i + 1][j] == 0) perimeter++;
                    // Check left neighbor
                    if (j == 0 || grid[i][j - 1] == 0) perimeter++;
                    // Check right neighbor
                    if (j == cols - 1 || grid[i][j + 1] == 0) perimeter++;
                }
            }
        }

        return perimeter;
    }
}
",1
"public class Solution {
    public int countSegments(String s) {
        int count = 0;
        boolean inSegment = false;
        
        for (char c : s.toCharArray()) {
            if (c != ' ') {
                if (!inSegment) {
                    count++;
                    inSegment = true;
                }
            } else {
                inSegment = false;
            }
        }
        
        return count;
    }
}
",1
"public class Solution {
    public int arrangeCoins(int n) {
        long left = 1;
        long right = n;
        
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long coinsNeeded = (mid * (mid + 1)) / 2;
            
            if (coinsNeeded <= n) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return (int) (left - 1);
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

public class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> result = new ArrayList<>();
        
        // Mark the numbers that we have encountered
        for (int num : nums) {
            int index = Math.abs(num) - 1;
            if (nums[index] > 0) {
                nums[index] = -nums[index];
            }
        }
        
        // Find the missing numbers
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                result.add(i + 1);
            }
        }
        
        return result;
    }
}
",1
"import java.util.Arrays;

public class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        
        int i = 0, j = 0;
        int contentChildren = 0;
        
        while (i < g.length && j < s.length) {
            if (s[j] >= g[i]) {
                contentChildren++;
                i++;
            }
            j++;
        }
        
        return contentChildren;
    }
}
",1
"public class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        if (timeSeries.length == 0) return 0;
        
        int totalPoisonedTime = duration;
        
        for (int i = 1; i < timeSeries.length; i++) {
            int timeDiff = timeSeries[i] - timeSeries[i - 1];
            totalPoisonedTime += Math.min(timeDiff, duration);
        }
        
        return totalPoisonedTime;
    }
}
",1
"public class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        
        for (int len = 1; len <= n / 2; len++) {
            if (n % len == 0) {
                String substring = s.substring(0, len);
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < n / len; i++) {
                    sb.append(substring);
                }
                if (sb.toString().equals(s)) {
                    return true;
                }
            }
        }
        
        return false;
    }
}
",1
"public class Solution {
    public int maximumProduct(int[] nums) {
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        
        for (int num : nums) {
            if (num > max1) {
                max3 = max2;
                max2 = max1;
                max1 = num;
            } else if (num > max2) {
                max3 = max2;
                max2 = num;
            } else if (num > max3) {
                max3 = num;
            }
            
            if (num < min1) {
                min2 = min1;
                min1 = num;
            } else if (num < min2) {
                min2 = num;
            }
        }
        
        return Math.max(max1 * max2 * max3, max1 * min1 * min2);
    }
}
",1
"public class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num <= 1) {
            return false;
        }
        
        int sum = 1; // 1 is always a divisor
        
        for (int i = 2; i * i <= num; i++) {
            if (num % i == 0) {
                sum += i;
                if (i * i != num) { // Avoid counting square root twice
                    sum += num / i;
                }
            }
        }
        
        return sum == num;
    }
}
",1
"import java.util.*;

public class Solution {
    public int[] constructRectangle(int area) {
        int[] result = new int[2];
        int minDiff = Integer.MAX_VALUE;
        
        for (int i = 1; i <= Math.sqrt(area); i++) {
            if (area % i == 0) {
                int length = area / i;
                int diff = Math.abs(length - i);
                if (diff < minDiff) {
                    minDiff = diff;
                    result[0] = length;
                    result[1] = i;
                }
            }
        }
        
        return result;
    }
}
",1
"class Solution {
    public String[] findRelativeRanks(int[] score) {
        int n=score.length;
        String[] result=new String[n];
        Integer[] indices=new Integer[n];
        for(int i=0;i<n;i++)
        {
            indices[i]=i;
        } 
        Arrays.sort(indices, (a,b) -> Integer.compare(score[b],score[a]));
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                result[indices[i]] = ""Gold Medal"";
            } else if (i == 1) {
                result[indices[i]] = ""Silver Medal"";
            } else if (i == 2) {
                result[indices[i]] = ""Bronze Medal"";
            } else {
                result[indices[i]] = String.valueOf(i + 1);
            }
        }
        return result;

        
    }
}",1
"public class Solution {
    public String convertToBase7(int num) {
        // Handle the case when num is 0
        if (num == 0) {
            return ""0"";
        }
        
        StringBuilder sb = new StringBuilder();
        boolean negative = false;
        
        // Handle the negative case
        if (num < 0) {
            negative = true;
            num = -num;
        }
        
        // Convert num to base 7
        while (num > 0) {
            int remainder = num % 7;
            sb.append(remainder);
            num /= 7;
        }
        
        // Reverse the string to get the correct base 7 representation
        sb.reverse();
        
        // Add a negative sign if necessary
        if (negative) {
            sb.insert(0, ""-"");
        }
        
        return sb.toString();
    }
}
",1
"public class Solution {
    public String licenseKeyFormatting(String s, int k) {
        StringBuilder sb = new StringBuilder();
        int count = 0;
        
        // Iterate through the characters of the modified string from right to left
        for (int i = s.length() - 1; i >= 0; i--) {
            char ch = s.charAt(i);
            
            // Ignore dashes
            if (ch == '-') {
                continue;
            }
            
            // Convert lowercase letters to uppercase
            if (ch >= 'a' && ch <= 'z') {
                ch = Character.toUpperCase(ch);
            }
            
            // Insert a dash after every k characters (except for the first group)
            if (count == k) {
                sb.append('-');
                count = 0;
            }
            
            sb.append(ch);
            count++;
        }
        
        // Reverse the string to get the correct order
        return sb.reverse().toString();
    }
}
",1
"public class Solution {
    public int findComplement(int num) {
        // Find the number of bits needed to represent num
        int mask = ~0; // All bits are set to 1
        while ((num & mask) != 0) {
            mask <<= 1;
        }
        
        // Flip all bits of num using XOR with the bitmask
        return ~num ^ mask;
    }
}
",1
"public class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int maxCount = 0;
        int currentCount = 0;
        
        for (int num : nums) {
            if (num == 1) {
                currentCount++;
                maxCount = Math.max(maxCount, currentCount);
            } else {
                currentCount = 0;
            }
        }
        
        return maxCount;
    }
}
",1
"public class Solution {
    public int hammingDistance(int x, int y) {
        int xor = x ^ y;
        int distance = 0;
        while (xor != 0) {
            distance += xor & 1;
            xor >>= 1;
        }
        return distance;
    }
}
",1
"class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    public TreeNode insertIntoMaxTree(TreeNode root, int val) {
        // If the current root is null, create a new node with the given value
        if (root == null) {
            return new TreeNode(val);
        }
        
        // If the value of the current root is less than the given value,
        // set the new node as the right child of the current root
        if (root.val < val) {
            TreeNode newNode = new TreeNode(val);
            newNode.left = root;
            return newNode;
        }
        
        // Otherwise, recursively insert the value into the right subtree
        root.right = insertIntoMaxTree(root.right, val);
        
        // Return the root of the modified tree
        return root;
    }
}
",1
"class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    int totalTilt = 0;

    public int findTilt(TreeNode root) {
        postorder(root);
        return totalTilt;
    }

    private int postorder(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // Recursively compute the sum of values in the left and right subtrees
        int leftSum = postorder(node.left);
        int rightSum = postorder(node.right);

        // Calculate the tilt of the current node
        int tilt = Math.abs(leftSum - rightSum);
        // Update the total tilt
        totalTilt += tilt;

        // Return the sum of values in the subtree rooted at the current node
        return node.val + leftSum + rightSum;
    }
}
",1
"class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isUniValued(root, root.val);
    }
    
    private boolean isUniValued(TreeNode node, int val) {
        if (node == null) {
            return true;
        }
        if (node.val != val) {
            return false;
        }
        return isUniValued(node.left, val) && isUniValued(node.right, val);
    }
}
",1
"class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    int maxDiameter = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        
        // Call the recursive function to calculate the diameter of the binary tree
        calculateDiameter(root);
        
        return maxDiameter;
    }
    
    private int calculateDiameter(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // Recursively calculate the depth of the left and right subtrees
        int leftDepth = calculateDiameter(node.left);
        int rightDepth = calculateDiameter(node.right);
        
        // Update the maximum diameter if the sum of left and right depths is greater
        maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);
        
        // Return the depth of the subtree rooted at the current node
        return 1 + Math.max(leftDepth, rightDepth);
    }
}
",1
"import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> averages = new ArrayList<>();
        if (root == null) {
            return averages;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            long sum = 0;
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                sum += node.val;
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            double average = (double) sum / size;
            averages.add(average);
        }
        
        return averages;
    }
}
",1
"import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        if (root == null) {
            return false;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            boolean foundX = false;
            boolean foundY = false;
            TreeNode parentX = null;
            TreeNode parentY = null;
            
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                
                if (node.left != null) {
                    queue.offer(node.left);
                    if (node.left.val == x) {
                        foundX = true;
                        parentX = node;
                    } else if (node.left.val == y) {
                        foundY = true;
                        parentY = node;
                    }
                }
                
                if (node.right != null) {
                    queue.offer(node.right);
                    if (node.right.val == x) {
                        foundX = true;
                        parentX = node;
                    } else if (node.right.val == y) {
                        foundY = true;
                        parentY = node;
                    }
                }
                
                if (foundX && foundY) {
                    return parentX != parentY;
                }
            }
            
            if (foundX || foundY) {
                return false; // One of the nodes is missing
            }
        }
        
        return false; // Both nodes are missing
    }
}
",1
"import java.util.PriorityQueue;

public class Solution {
    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
        for (int stone : stones) {
            maxHeap.offer(stone);
        }
        while (maxHeap.size() > 1) {
            int x = maxHeap.poll();
            int y = maxHeap.poll();
            if (x != y) {
                maxHeap.offer(Math.abs(x - y));
            }
        }
        return maxHeap.isEmpty() ? 0 : maxHeap.poll();
    }
}
",1
"import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> nextGreater = new HashMap<>();
        Deque<Integer> stack = new ArrayDeque<>();
        
        for (int num : nums2) {
            while (!stack.isEmpty() && stack.peek() < num) {
                nextGreater.put(stack.pop(), num);
            }
            stack.push(num);
        }
        
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreater.getOrDefault(nums1[i], -1);
        }
        
        return result;
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

public class Solution {
    public String[] findWords(String[] words) {
        String[] rows = {""qwertyuiop"", ""asdfghjkl"", ""zxcvbnm""};
        List<String> result = new ArrayList<>();
        
        for (String word : words) {
            boolean found = true;
            String row = null;
            
            for (String r : rows) {
                if (r.contains(Character.toString(word.toLowerCase().charAt(0)))) {
                    row = r;
                    break;
                }
            }
            
            for (char c : word.toLowerCase().toCharArray()) {
                if (!row.contains(Character.toString(c))) {
                    found = false;
                    break;
                }
            }
            
            if (found) {
                result.add(word);
            }
        }
        
        return result.toArray(new String[result.size()]);
    }
}
",1
"public class Solution {
    public int findLUSlength(String a, String b) {
        if (a.equals(b)) {
            return -1;
        } else {
            return Math.max(a.length(), b.length());
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(solution.findLUSlength(""aba"", ""cdc"")); // Output: 3
        System.out.println(solution.findLUSlength(""aaa"", ""bbb"")); // Output: 3
        System.out.println(solution.findLUSlength(""aaa"", ""aaa"")); // Output: -1
    }
}
",1
"public class Solution {
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }
        
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(solution.fib(2)); // Output: 1
        System.out.println(solution.fib(3)); // Output: 2
        System.out.println(solution.fib(4)); // Output: 3
    }
}
",1
"public class Solution {
    public boolean detectCapitalUse(String word) {
        int countUpper = 0;
        
        for (char c : word.toCharArray()) {
            if (Character.isUpperCase(c)) {
                countUpper++;
            }
        }
        
        return countUpper == word.length() || countUpper == 0 || (countUpper == 1 && Character.isUpperCase(word.charAt(0)));
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(solution.detectCapitalUse(""USA"")); // Output: true
        System.out.println(solution.detectCapitalUse(""FlaG"")); // Output: false
    }
}
",1
"public class Solution {
    public String toLowerCase(String s) {
        StringBuilder sb = new StringBuilder();

        for (char c : s.toCharArray()) {
            if (Character.isUpperCase(c)) {
                // Convert uppercase letter to lowercase
                sb.append(Character.toLowerCase(c));
            } else {
                // Leave non-uppercase letters unchanged
                sb.append(c);
            }
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(solution.toLowerCase(""Hello"")); // Output: ""hello""
        System.out.println(solution.toLowerCase(""here"")); // Output: ""here""
        System.out.println(solution.toLowerCase(""LOVELY"")); // Output: ""lovely""
    }
}
",1
"public class Solution {
    public int countBinarySubstrings(String s) {
        int count = 0;
        int prevLength = 0;
        int currLength = 1;

        for (int i = 1; i < s.length(); i++) {
            // Check if current character is different from previous character
            if (s.charAt(i) != s.charAt(i - 1)) {
                // Count substrings formed by consecutive groups of 0's and 1's
                count += Math.min(prevLength, currLength);
                prevLength = currLength;
                currLength = 1;
            } else {
                // Increment length of consecutive group
                currLength++;
            }
        }

        // Add count of substrings for the last consecutive group
        count += Math.min(prevLength, currLength);

        return count;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(solution.countBinarySubstrings(""00110011"")); // Output: 6
        System.out.println(solution.countBinarySubstrings(""10101"")); // Output: 4
    }
}
",1
"import java.util.HashSet;
import java.util.Set;

public class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        Set<Character> jewelSet = new HashSet<>();
        
        // Add each jewel type to the set
        for (char jewel : jewels.toCharArray()) {
            jewelSet.add(jewel);
        }
        
        int count = 0;
        // Count the stones that are also jewels
        for (char stone : stones.toCharArray()) {
            if (jewelSet.contains(stone)) {
                count++;
            }
        }
        
        return count;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(solution.numJewelsInStones(""aA"", ""aAAbbbb"")); // Output: 3
        System.out.println(solution.numJewelsInStones(""z"", ""ZZ"")); // Output: 0
    }
}
",1
"public class Solution {
    public boolean checkRecord(String s) {
        int absentCount = 0;
        int lateCount = 0;

        for (char c : s.toCharArray()) {
            if (c == 'A') {
                absentCount++;
                if (absentCount >= 2) {
                    return false; // More than 1 absence, not eligible
                }
                lateCount = 0; // Reset late count
            } else if (c == 'L') {
                lateCount++;
                if (lateCount >= 3) {
                    return false; // 3 consecutive late days, not eligible
                }
            } else { // 'P'
                lateCount = 0; // Reset late count
            }
        }

        return true; // Eligible if no more than 1 absence and no 3 consecutive late days
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(solution.checkRecord(""PPALLP"")); // Output: true
        System.out.println(solution.checkRecord(""PPALLL"")); // Output: false
    }
}
",1
"public class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int left = 0, right = nums.length - 1;

        while (left < right) {
            while (left < right && nums[left] % 2 == 0) {
                left++;
            }
            while (left < right && nums[right] % 2 != 0) {
                right--;
            }
            if (left < right) {
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
                right--;
            }
        }

        return nums;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] nums1 = {3, 1, 2, 4};
        int[] result1 = solution.sortArrayByParity(nums1);
        System.out.println(Arrays.toString(result1)); // Output: [4, 2, 1, 3]

        int[] nums2 = {0};
        int[] result2 = solution.sortArrayByParity(nums2);
        System.out.println(Arrays.toString(result2)); // Output: [0]
    }
}
",1
"public class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int left = 0, right = letters.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return left < letters.length ? letters[left] : letters[0];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        char[] letters1 = {'c', 'f', 'j'};
        char target1 = 'a';
        System.out.println(solution.nextGreatestLetter(letters1, target1)); // Output: 'c'

        char[] letters2 = {'c', 'f', 'j'};
        char target2 = 'c';
        System.out.println(solution.nextGreatestLetter(letters2, target2)); // Output: 'f'

        char[] letters3 = {'x', 'x', 'y', 'y'};
        char target3 = 'z';
        System.out.println(solution.nextGreatestLetter(letters3, target3)); // Output: 'x'
    }
}
",1
"import java.util.Stack;

public class Solution {
    public int calPoints(String[] ops) {
        Stack<Integer> stack = new Stack<>();

        for (String op : ops) {
            if (op.equals(""+"")) {
                int top = stack.pop();
                int newTop = top + stack.peek();
                stack.push(top);
                stack.push(newTop);
            } else if (op.equals(""D"")) {
                stack.push(2 * stack.peek());
            } else if (op.equals(""C"")) {
                stack.pop();
            } else {
                stack.push(Integer.parseInt(op));
            }
        }

        int sum = 0;
        for (int score : stack) {
            sum += score;
        }

        return sum;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        String[] ops1 = {""5"",""2"",""C"",""D"",""+""};
        System.out.println(solution.calPoints(ops1)); // Output: 30

        String[] ops2 = {""5"",""-2"",""4"",""C"",""D"",""9"",""+"",""+""};
        System.out.println(solution.calPoints(ops2)); // Output: 27

        String[] ops3 = {""1"",""C""};
        System.out.println(solution.calPoints(ops3)); // Output: 0
    }
}
",1
"import java.util.Arrays;

public class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < nums.length; i += 2) {
            sum += nums[i];
        }
        return sum;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] nums1 = {1, 4, 3, 2};
        System.out.println(solution.arrayPairSum(nums1)); // Output: 4

        int[] nums2 = {6, 2, 6, 5, 1, 2};
        System.out.println(solution.arrayPairSum(nums2)); // Output: 9
    }
}
",1
"public class Solution {
    public int pivotIndex(int[] nums) {
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (leftSum == totalSum - leftSum - nums[i]) {
                return i;
            }
            leftSum += nums[i];
        }
        
        return -1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] nums1 = {1, 7, 3, 6, 5, 6};
        System.out.println(solution.pivotIndex(nums1)); // Output: 3

        int[] nums2 = {1, 2, 3};
        System.out.println(solution.pivotIndex(nums2)); // Output: -1

        int[] nums3 = {2, 1, -1};
        System.out.println(solution.pivotIndex(nums3)); // Output: 0
    }
}
",1
"public class Solution {
    public boolean judgeCircle(String moves) {
        int countU = 0, countD = 0, countL = 0, countR = 0;
        
        for (char move : moves.toCharArray()) {
            if (move == 'U') countU++;
            else if (move == 'D') countD++;
            else if (move == 'L') countL++;
            else if (move == 'R') countR++;
        }
        
        return countU == countD && countL == countR;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        String moves1 = ""UD"";
        System.out.println(solution.judgeCircle(moves1)); // Output: true

        String moves2 = ""LL"";
        System.out.println(solution.judgeCircle(moves2)); // Output: false
    }
}
",1
"public class Solution {
    public int[][] imageSmoother(int[][] img) {
        int m = img.length;
        int n = img[0].length;
        int[][] result = new int[m][n];
        
        int[][] directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 0}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int sum = 0;
                int count = 0;
                
                for (int[] dir : directions) {
                    int newRow = i + dir[0];
                    int newCol = j + dir[1];
                    
                    if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n) {
                        sum += img[newRow][newCol];
                        count++;
                    }
                }
                
                result[i][j] = sum / count;
            }
        }
        
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[][] img1 = {{1, 1, 1}, {1, 0, 1}, {1, 1, 1}};
        int[][] result1 = solution.imageSmoother(img1);
        for (int[] row : result1) {
            System.out.println(Arrays.toString(row));
        }

        int[][] img2 = {{100, 200, 100}, {200, 50, 200}, {100, 200, 100}};
        int[][] result2 = solution.imageSmoother(img2);
        for (int[] row : result2) {
            System.out.println(Arrays.toString(row));
        }
    }
}
",1
"public class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] nums1 = {-1, 0, 3, 5, 9, 12};
        int target1 = 9;
        System.out.println(solution.search(nums1, target1)); // Output: 4

        int[] nums2 = {-1, 0, 3, 5, 9, 12};
        int target2 = 2;
        System.out.println(solution.search(nums2, target2)); // Output: -1
    }
}
",1
"class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
    }
}

public class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        
        if (val < root.val) {
            return searchBST(root.left, val);
        } else {
            return searchBST(root.right, val);
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Example 1
        TreeNode root1 = new TreeNode(4);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(7);
        root1.left.left = new TreeNode(1);
        root1.left.right = new TreeNode(3);
        int val1 = 2;
        TreeNode result1 = solution.searchBST(root1, val1);
        solution.printTree(result1); // Output: [2,1,3]

        // Example 2
        TreeNode root2 = new TreeNode(4);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(7);
        root2.left.left = new TreeNode(1);
        root2.left.right = new TreeNode(3);
        int val2 = 5;
        TreeNode result2 = solution.searchBST(root2, val2);
        solution.printTree(result2); // Output: null
    }
    
    private void printTree(TreeNode root) {
        if (root == null) {
            System.out.println(""[]"");
            return;
        }
        
        System.out.print(""["");
        printTreeHelper(root);
        System.out.println(""]"");
    }
    
    private void printTreeHelper(TreeNode node) {
        if (node == null) {
            return;
        }
        
        System.out.print(node.val);
        if (node.left != null || node.right != null) {
            System.out.print("","");
            printTreeHelper(node.left);
            System.out.print("","");
            printTreeHelper(node.right);
        }
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

public class Solution {
    public List<List<Integer>> largeGroupPositions(String s) {
        List<List<Integer>> result = new ArrayList<>();
        
        int start = 0;
        char prevChar = s.charAt(0);
        for (int i = 1; i < s.length(); i++) {
            char currentChar = s.charAt(i);
            if (currentChar != prevChar) {
                if (i - start >= 3) {
                    List<Integer> interval = new ArrayList<>();
                    interval.add(start);
                    interval.add(i - 1);
                    result.add(interval);
                }
                start = i;
                prevChar = currentChar;
            }
        }
        
        // Check for the last group
        if (s.length() - start >= 3) {
            List<Integer> interval = new ArrayList<>();
            interval.add(start);
            interval.add(s.length() - 1);
            result.add(interval);
        }
        
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Example 1
        String s1 = ""abbxxxxzzy"";
        List<List<Integer>> result1 = solution.largeGroupPositions(s1);
        System.out.println(result1); // Output: [[3,6]]

        // Example 2
        String s2 = ""abc"";
        List<List<Integer>> result2 = solution.largeGroupPositions(s2);
        System.out.println(result2); // Output: []

        // Example 3
        String s3 = ""abcdddeeeeaabbbcd"";
        List<List<Integer>> result3 = solution.largeGroupPositions(s3);
        System.out.println(result3); // Output: [[3,5],[6,9],[12,14]]
    }
}
",1
"public class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int i = 0;
        while (i < bits.length - 1) {
            if (bits[i] == 0) {
                i++; // Move to the next bit
            } else {
                i += 2; // Skip the next bit
            }
        }
        // If we reach the end of the array, the last character must be a one-bit character
        return i == bits.length - 1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Example 1
        int[] bits1 = {1, 0, 0};
        System.out.println(solution.isOneBitCharacter(bits1)); // Output: true

        // Example 2
        int[] bits2 = {1, 1, 1, 0};
        System.out.println(solution.isOneBitCharacter(bits2)); // Output: false
    }
}
",1
"public class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        // Check if rec1 is to the left of rec2
        if (rec1[2] <= rec2[0])
            return false;
        // Check if rec1 is to the right of rec2
        if (rec1[0] >= rec2[2])
            return false;
        // Check if rec1 is above rec2
        if (rec1[3] <= rec2[1])
            return false;
        // Check if rec1 is below rec2
        if (rec1[1] >= rec2[3])
            return false;
        // If none of the above conditions are true, the rectangles overlap
        return true;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Example 1
        int[] rec1 = {0, 0, 2, 2};
        int[] rec2 = {1, 1, 3, 3};
        System.out.println(solution.isRectangleOverlap(rec1, rec2)); // Output: true

        // Example 2
        int[] rec3 = {0, 0, 1, 1};
        int[] rec4 = {1, 0, 2, 1};
        System.out.println(solution.isRectangleOverlap(rec3, rec4)); // Output: false

        // Example 3
        int[] rec5 = {0, 0, 1, 1};
        int[] rec6 = {2, 2, 3, 3};
        System.out.println(solution.isRectangleOverlap(rec5, rec6)); // Output: false
    }
}
",1
"public class Solution {
    public boolean lemonadeChange(int[] bills) {
        int count5 = 0, count10 = 0;

        for (int bill : bills) {
            if (bill == 5) {
                count5++;
            } else if (bill == 10) {
                if (count5 == 0) {
                    return false;
                }
                count5--;
                count10++;
            } else {
                if (count10 > 0 && count5 > 0) {
                    count10--;
                    count5--;
                } else if (count5 >= 3) {
                    count5 -= 3;
                } else {
                    return false;
                }
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Example 1
        int[] bills1 = {5, 5, 5, 10, 20};
        System.out.println(solution.lemonadeChange(bills1)); // Output: true

        // Example 2
        int[] bills2 = {5, 5, 10, 10, 20};
        System.out.println(solution.lemonadeChange(bills2)); // Output: false
    }
}
",1
"public class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int maxLength = 1;
        int currentLength = 1;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                currentLength++;
                maxLength = Math.max(maxLength, currentLength);
            } else {
                currentLength = 1;
            }
        }

        return maxLength;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] nums1 = {1, 3, 5, 4, 7};
        System.out.println(solution.findLengthOfLCIS(nums1)); // Output: 3

        int[] nums2 = {2, 2, 2, 2, 2};
        System.out.println(solution.findLengthOfLCIS(nums2)); // Output: 1
    }
}
",1
"public class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int m = mat.length;
        int n = mat[0].length;

        // If the number of elements is not the same, return the original matrix
        if (m * n != r * c) {
            return mat;
        }

        int[][] reshaped = new int[r][c];
        int rowIndex = 0;
        int colIndex = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                reshaped[rowIndex][colIndex++] = mat[i][j];
                if (colIndex == c) {
                    colIndex = 0;
                    rowIndex++;
                }
            }
        }

        return reshaped;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[][] mat1 = {{1, 2}, {3, 4}};
        int[][] result1 = solution.matrixReshape(mat1, 1, 4);
        for (int[] row : result1) {
            System.out.println(Arrays.toString(row));
        }

        int[][] mat2 = {{1, 2}, {3, 4}};
        int[][] result2 = solution.matrixReshape(mat2, 2, 4);
        for (int[] row : result2) {
            System.out.println(Arrays.toString(row));
        }
    }
}
",1
"public class Solution {
    public int[] numberOfLines(int[] widths, String s) {
        int lines = 1; // Start with one line
        int width = 0; // Width of the current line
        for (char c : s.toCharArray()) {
            int charWidth = widths[c - 'a'];
            // If adding the current character exceeds the width limit
            if (width + charWidth > 100) {
                lines++; // Start a new line
                width = charWidth; // Reset the width for the new line
            } else {
                width += charWidth; // Add the character width to the current line
            }
        }
        return new int[]{lines, width};
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] widths1 = {10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10};
        String s1 = ""abcdefghijklmnopqrstuvwxyz"";
        int[] result1 = solution.numberOfLines(widths1, s1);
        System.out.println(Arrays.toString(result1)); // Output: [3, 60]

        int[] widths2 = {4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10};
        String s2 = ""bbbcccdddaaa"";
        int[] result2 = solution.numberOfLines(widths2, s2);
        System.out.println(Arrays.toString(result2)); // Output: [2, 4]
    }
}
",1
"import java.util.HashMap;

public class Solution {
    public int countCharacters(String[] words, String chars) {
        int result = 0;
        HashMap<Character, Integer> charCount = new HashMap<>();
        
        // Count the frequency of each character in chars
        for (char c : chars.toCharArray()) {
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        }
        
        // Check each word
        for (String word : words) {
            HashMap<Character, Integer> wordCount = new HashMap<>();
            boolean goodWord = true;
            
            // Count the frequency of each character in the current word
            for (char c : word.toCharArray()) {
                wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);
            }
            
            // Check if the current word can be formed
            for (char c : wordCount.keySet()) {
                if (!charCount.containsKey(c) || wordCount.get(c) > charCount.get(c)) {
                    goodWord = false;
                    break;
                }
            }
            
            // If the word is good, add its length to the result
            if (goodWord) {
                result += word.length();
            }
        }
        
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        String[] words1 = {""cat"",""bt"",""hat"",""tree""};
        String chars1 = ""atach"";
        System.out.println(solution.countCharacters(words1, chars1)); // Output: 6

        String[] words2 = {""hello"",""world"",""leetcode""};
        String chars2 = ""welldonehoneyr"";
        System.out.println(solution.countCharacters(words2, chars2)); // Output: 10
    }
}
",1
"public class Solution {
    public int dominantIndex(int[] nums) {
        int maxIndex = 0;
        int maxNum = nums[0];
        
        // Find the index of the largest element
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > maxNum) {
                maxIndex = i;
                maxNum = nums[i];
            }
        }
        
        // Check if the largest element is at least twice as much as every other number
        for (int i = 0; i < nums.length; i++) {
            if (i != maxIndex && maxNum < nums[i] * 2) {
                return -1;
            }
        }
        
        return maxIndex;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        int[] nums1 = {3,6,1,0};
        System.out.println(solution.dominantIndex(nums1)); // Output: 1

        int[] nums2 = {1,2,3,4};
        System.out.println(solution.dominantIndex(nums2)); // Output: -1
    }
}
",1
"class Solution {
    public boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
",1
"import java.util.*;

class Solution {
    public String[] uncommonFromSentences(String s1, String s2) {
        // Create a map to store the frequency of each word
        Map<String, Integer> wordCount = new HashMap<>();
        
        // Helper function to add words to the map
        addWordsToMap(s1, wordCount);
        addWordsToMap(s2, wordCount);
        
        // List to store the result
        List<String> result = new ArrayList<>();
        
        // Find words with a count of 1 in the map
        for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {
            if (entry.getValue() == 1) {
                result.add(entry.getKey());
            }
        }
        
        // Convert the result list to an array and return it
        return result.toArray(new String[0]);
    }
    
    // Helper function to add words to the map
    private void addWordsToMap(String sentence, Map<String, Integer> wordCount) {
        String[] words = sentence.split("" "");
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
    }
    
    // Example usage
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(Arrays.toString(solution.uncommonFromSentences(""this apple is sweet"", ""this apple is sour""))); // Output: [""sweet"",""sour""]
        System.out.println(Arrays.toString(solution.uncommonFromSentences(""apple apple"", ""banana""))); // Output: [""banana""]
    }
}
",1
"class MyHashSet {
    private static final int SIZE = 10000;
    private Bucket[] buckets;

    public MyHashSet() {
        buckets = new Bucket[SIZE];
        for (int i = 0; i < SIZE; i++) {
            buckets[i] = new Bucket();
        }
    }

    public void add(int key) {
        int index = hash(key);
        buckets[index].insert(key);
    }

    public void remove(int key) {
        int index = hash(key);
        buckets[index].delete(key);
    }

    public boolean contains(int key) {
        int index = hash(key);
        return buckets[index].exists(key);
    }

    private int hash(int key) {
        return key % SIZE;
    }

    private class Bucket {
        private LinkedList<Integer> list;

        public Bucket() {
            list = new LinkedList<>();
        }

        public void insert(Integer key) {
            if (!list.contains(key)) {
                list.addFirst(key);
            }
        }

        public void delete(Integer key) {
            list.remove(key);
        }

        public boolean exists(Integer key) {
            return list.contains(key);
        }
    }
}

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 */
",1
"public class Solution {
    public String removeOuterParentheses(String s) {
        StringBuilder result = new StringBuilder();
        int balance = 0; // To keep track of the balance of the parentheses
        int start = 0; // To mark the start of a primitive part
        
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (ch == '(') {
                if (balance == 0) {
                    start = i; // Mark the start of a primitive part
                }
                balance++;
            } else {
                balance--;
                if (balance == 0) {
                    // Primitive part ends at index i
                    result.append(s.substring(start + 1, i)); // Append the inner part without the outermost parentheses
                }
            }
        }
        
        return result.toString();
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        // Test cases
        System.out.println(sol.removeOuterParentheses(""(()())(())"")); // Output: ""()()()""
        System.out.println(sol.removeOuterParentheses(""(()())(())(()(()))"")); // Output: ""()()()()(())""
        System.out.println(sol.removeOuterParentheses(""()()"")); // Output: """"
    }
}
",1
"import java.util.HashSet;

public class Solution {
    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {
        int sumAlice = 0, sumBob = 0;
        HashSet<Integer> aliceSet = new HashSet<>();
        
        // Calculate sums and store Alice's sizes in a set
        for (int size : aliceSizes) {
            sumAlice += size;
            aliceSet.add(size);
        }
        
        for (int size : bobSizes) {
            sumBob += size;
        }
        
        // Calculate the target sum after exchange
        int target = (sumAlice + sumBob) / 2;
        
        // Iterate through Bob's sizes to find a valid swap
        for (int boxBob : bobSizes) {
            int desiredAlice = boxBob + (target - sumBob);
            if (aliceSet.contains(desiredAlice)) {
                return new int[] { desiredAlice, boxBob };
            }
        }
        
        // If no solution found (though guaranteed there is one according to problem statement)
        return new int[] { -1, -1 }; // This line should never execute due to problem constraints
    }
}
",1
"class Solution {
    public String convert(String s, int numRows) {
        if (numRows == 1) return s; // Special case if only one row

        StringBuilder[] rows = new StringBuilder[Math.min(numRows, s.length())];
        for (int i = 0; i < rows.length; i++) {
            rows[i] = new StringBuilder();
        }

        int currRow = 0;
        boolean goingDown = false;

        for (char c : s.toCharArray()) {
            rows[currRow].append(c);
            if (currRow == 0 || currRow == numRows - 1) goingDown = !goingDown;
            currRow += goingDown ? 1 : -1;
        }

        StringBuilder result = new StringBuilder();
        for (StringBuilder row : rows) {
            result.append(row);
        }

        return result.toString();
    }
}
",1
"class Solution {
    public int reverse(int x) {
        int reversed = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            // Check for overflow before actually updating reversed
            if (reversed > Integer.MAX_VALUE/10 || (reversed == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (reversed < Integer.MIN_VALUE/10 || (reversed == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            reversed = reversed * 10 + pop;
        }
        return reversed;
    }
}
",1
"class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return """";
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i); // Odd length palindromes
            int len2 = expandAroundCenter(s, i, i + 1); // Even length palindromes
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}
",1
"class Solution {
    public int maxArea(int[] height) {
        int left = 0; // Initialize the left pointer
        int right = height.length - 1; // Initialize the right pointer
        int maxArea = 0; // Variable to store the maximum area

        while (left < right) {
            // Calculate the current area
            int width = right - left;
            int currentHeight = Math.min(height[left], height[right]);
            int currentArea = width * currentHeight;
            // Update the maximum area if the current area is greater
            maxArea = Math.max(maxArea, currentArea);

            // Move the pointer which is at the shorter line
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
}
",1
"class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];

        // Base case: empty string and empty pattern are a match
        dp[0][0] = true;

        // Handle patterns like a*, a*b*, a*b*c*
        for (int j = 2; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }

        // Fill the dp array
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    dp[i][j] = dp[i][j - 2]; // Consider zero occurrence of the character before *
                    if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) {
                        dp[i][j] = dp[i][j] || dp[i - 1][j]; // Consider one or more occurrence of the character before *
                    }
                }
            }
        }

        return dp[m][n];
    }
}
",1
"class Solution {
    public String intToRoman(int num) {
        // Define the mapping of Roman numerals
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] symbols = {""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"", ""V"", ""IV"", ""I""};

        StringBuilder sb = new StringBuilder();
        
        // Iterate through each value-symbol pair
        for (int i = 0; i < values.length && num > 0; i++) {
            // Append the symbol while the value can be subtracted from num
            while (num >= values[i]) {
                num -= values[i];
                sb.append(symbols[i]);
            }
        }
        
        return sb.toString();
    }
}
",1
"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // Sort the array
        
        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // Skip duplicate elements
            
            int left = i + 1;
            int right = nums.length - 1;
            
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while (left < right && nums[left] == nums[left + 1]) left++; // Skip duplicates
                    while (left < right && nums[right] == nums[right - 1]) right--; // Skip duplicates
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        
        return result;
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, """", 0, 0, n);
        return result;
    }
    
    private void backtrack(List<String> result, String current, int open, int close, int max) {
        if (current.length() == max * 2) {
            result.add(current);
            return;
        }
        
        if (open < max) {
            backtrack(result, current + ""("", open + 1, close, max);
        }
        if (close < open) {
            backtrack(result, current + "")"", open, close + 1, max);
        }
    }
}
",1
"import java.util.*;

class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }

    public static ListNode deserialize(String data) {
        if (data.equals(""[]"")) return null;

        String[] values = data.substring(1, data.length() - 1).split("","");
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        for (String val : values) {
            current.next = new ListNode(Integer.parseInt(val.trim()));
            current = current.next;
        }

        return dummy.next;
    }

    public static String serialize(ListNode node) {
        StringBuilder sb = new StringBuilder();
        sb.append(""["");
        while (node != null) {
            sb.append(node.val);
            if (node.next != null) {
                sb.append("","");
            }
            node = node.next;
        }
        sb.append(""]"");
        return sb.toString();
    }
}

class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;

        while (head != null && head.next != null) {
            ListNode first = head;
            ListNode second = head.next;

            prev.next = second;
            first.next = second.next;
            second.next = first;

            prev = first;
            head = first.next;
        }

        return dummy.next;
    }
}

public class Main {
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        ListNode head = ListNode.deserialize(""[1,2,3,4]"");
        ListNode swapped = solution.swapPairs(head);
        String result = ListNode.serialize(swapped);
        
        System.out.println(result); // Expected output: [2,1,4,3]
    }
}
",1
"import java.util.*;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 4) {
            return result;
        }

        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // Skip duplicate elements

            for (int j = i + 1; j < nums.length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue; // Skip duplicate elements

                int left = j + 1;
                int right = nums.length - 1;

                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];

                    if (sum == target) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));

                        while (left < right && nums[left] == nums[left + 1]) left++; // Skip duplicate elements
                        while (left < right && nums[right] == nums[right - 1]) right--; // Skip duplicate elements

                        left++;
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }

        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        
        int[] nums1 = {1, 0, -1, 0, -2, 2};
        int target1 = 0;
        System.out.println(solution.fourSum(nums1, target1)); // Expected output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]

        int[] nums2 = {2, 2, 2, 2, 2};
        int target2 = 8;
        System.out.println(solution.fourSum(nums2, target2)); // Expected output: [[2, 2, 2, 2]]
    }
}
",1
"import java.util.ArrayList;
import java.util.List;

class Solution {
    private static final String[] KEYPAD = {
        """",     // 0
        """",     // 1
        ""abc"",  // 2
        ""def"",  // 3
        ""ghi"",  // 4
        ""jkl"",  // 5
        ""mno"",  // 6
        ""pqrs"", // 7
        ""tuv"",  // 8
        ""wxyz""  // 9
    };

    public List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();
        if (digits == null || digits.length() == 0) {
            return result;
        }

        backtrack(result, new StringBuilder(), digits, 0);
        return result;
    }

    private void backtrack(List<String> result, StringBuilder current, String digits, int index) {
        if (index == digits.length()) {
            result.add(current.toString());
            return;
        }

        String letters = KEYPAD[digits.charAt(index) - '0'];
        for (char letter : letters.toCharArray()) {
            current.append(letter);
            backtrack(result, current, digits, index + 1);
            current.deleteCharAt(current.length() - 1);
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        
        String digits1 = ""23"";
        System.out.println(solution.letterCombinations(digits1)); // Expected output: [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]

        String digits2 = """";
        System.out.println(solution.letterCombinations(digits2)); // Expected output: []

        String digits3 = ""2"";
        System.out.println(solution.letterCombinations(digits3)); // Expected output: [""a"",""b"",""c""]
    }
}
",1
"import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        // Create a Scanner object to read input
        Scanner sc = new Scanner(System.in);

        // Read the input string S
        String S = sc.nextLine();

        // Remove all occurrences of '.' from the string
        String result = S.replace(""."", """");

        // Print the result
        System.out.println(result);

        // Close the scanner
        sc.close();
    }
}
",1
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        List<Integer> list = new ArrayList<>();
        
        // Convert m into a sum of cubes (approach inspired from base-3 conversion)
        for (int i = 0; m > 0; i++) {
            // While m is not divisible by 3, subtract 1 and add the index 'i' to the list
            while (m % 3 != 0) {
                m--;               // Decrease m by 1
                list.add(i);        // Add the current index as part of the solution
            }
            m /= 3;  // Divide m by 3 to move to the next term
        }
        
        // Output the result
        System.out.println(list.size());  // Print the size of the list (N)
        for (Integer i : list) {
            System.out.print(i + "" "");  // Print each element in the list
        }
    }
}
",1
"import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), q = sc.nextInt();
        StringBuilder s = new StringBuilder(sc.next());  // No extra commas needed.
        
        // Initial count of ""ABC""
        int ans = 0;
        for (int i = 0; i <= n - 3; i++) {
            if (s.substring(i, i + 3).equals(""ABC"")) {
                ans++;
            }
        }

        // Processing queries
        for (int i = 0; i < q; i++) {
            int x = sc.nextInt() - 1;  // Convert to 0-based index
            char newChar = sc.next().charAt(0);
            
            // Only check the relevant range around the update
            for (int j = Math.max(0, x - 2); j <= Math.min(n - 3, x); j++) {
                if (s.substring(j, j + 3).equals(""ABC"")) {
                    ans--;  // Subtract ""ABC"" before making the change
                }
            }

            // Update the character at position x
            s.setCharAt(x, newChar);

            // Re-check the relevant range around the updated character
            for (int j = Math.max(0, x - 2); j <= Math.min(n - 3, x); j++) {
                if (s.substring(j, j + 3).equals(""ABC"")) {
                    ans++;  // Add ""ABC"" if it now exists after the change
                }
            }

            // Output the current number of ""ABC""
            System.out.println(ans);
        }

        sc.close();
    }
}
",1
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        int buildingCount = scanner.nextInt();
        int[] heights = new int[buildingCount + 1];
        
        // Input heights
        for (int i = 1; i <= buildingCount; i++) {
            heights[i] = scanner.nextInt();
        }
        
        // Array to store nearest taller building index for each building
        int[] nearestTaller = new int[buildingCount + 1];
        Stack<Integer> indexStack = new Stack<>();
        
        // Finding the nearest taller building for each building
        for (int current = 1; current <= buildingCount; current++) {
            while (!indexStack.isEmpty() && heights[indexStack.peek()] <= heights[current]) {
                indexStack.pop();
            }
            nearestTaller[current] = indexStack.isEmpty() ? 0 : indexStack.peek();
            indexStack.push(current);
        }
        
        // Differential array to count the number of visible buildings
        int[] countDiff = new int[buildingCount + 2];
        
        for (int j = 1; j <= buildingCount; j++) {
            int start = (nearestTaller[j] == 0) ? 1 : nearestTaller[j];
            int end = j - 1;
            if (start <= end) {
                countDiff[start]++;
                countDiff[end + 1]--;
            }
        }
        
        // Array to store the final visible count for each building
        int[] visibleCount = new int[buildingCount + 1];
        visibleCount[1] = countDiff[1];
        
        // Accumulate the counts from the differential array
        for (int i = 2; i <= buildingCount; i++) {
            visibleCount[i] = visibleCount[i - 1] + countDiff[i];
        }
        
        // Print the result
        for (int i = 1; i <= buildingCount; i++) {
            System.out.print(visibleCount[i] + (i < buildingCount ? "" "" : ""\n""));
        }
        
        scanner.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int year = sc.nextInt();
        
        // Checking leap year conditions
        if (year % 400 == 0) {
            System.out.println(366);
        } else if (year % 100 == 0) {
            System.out.println(365);
        } else if (year % 4 == 0) {
            System.out.println(366);
        } else {
            System.out.println(365);
        }
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Read the number of elements
        int n = sc.nextInt();
        
        // Read the array
        int[] A = new int[n];
        for (int i = 0; i < n; i++) {
            A[i] = sc.nextInt();
        }
        
        // Find the largest element and its index
        int maxIdx = 0;
        for (int i = 1; i < n; i++) {
            if (A[i] > A[maxIdx]) {
                maxIdx = i;
            }
        }
        
        // Find the second largest element
        int secondMaxIdx = -1;
        for (int i = 0; i < n; i++) {
            if (i != maxIdx) {
                if (secondMaxIdx == -1 || A[i] > A[secondMaxIdx]) {
                    secondMaxIdx = i;
                }
            }
        }
        
        // Output the 1-based index of the second largest element
        System.out.println(secondMaxIdx + 1);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Read the number of people and the budget
        int N = sc.nextInt();
        long M = sc.nextLong();

        // Read the transportation costs
        int[] A = new int[N];
        long totalCost = 0;
        int maxA = 0;
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextInt();
            totalCost += A[i];
            maxA = Math.max(maxA, A[i]);
        }

        // If the total cost is less than or equal to the budget, the answer is infinite
        if (totalCost <= M) {
            System.out.println(""infinite"");
            return;
        }

        // Binary search to find the maximum subsidy limit x
        long left = 0, right = maxA;
        while (left < right) {
            long mid = (left + right + 1) / 2;  // Try mid as a potential limit x
            if (canSubsidize(mid, A, N, M)) {
                left = mid;  // If it's possible, try a larger x
            } else {
                right = mid - 1;  // Otherwise, try a smaller x
            }
        }

        // Output the result
        System.out.println(left);
    }

    // Function to check if the total subsidy is within the budget for a given x
    private static boolean canSubsidize(long x, int[] A, int N, long M) {
        long totalSubsidy = 0;
        for (int i = 0; i < N; i++) {
            totalSubsidy += Math.min(x, A[i]);
            if (totalSubsidy > M) {
                return false;  // If it exceeds the budget, return false
            }
        }
        return true;
    }
}
",1
"import java.util.HashMap;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        char[] s = sc.next().toCharArray();
        sc.close();

        // HashMap to convert 'R', 'P', 'S' to integers for easier handling
        HashMap<Character, Integer> toNum = new HashMap<>();
        toNum.put('R', 0); // Rock
        toNum.put('P', 1); // Paper
        toNum.put('S', 2); // Scissors

        // DP array to store the maximum wins for each move
        int[][] dp = new int[n+1][3];

        // Loop through each round
        for (int i = 1; i <= n; i++) {
            int aokiMove = toNum.get(s[i-1]); // Aoki's move
            int winMove = (aokiMove + 1) % 3; // The move that beats Aoki's move
            int drawMove = aokiMove;          // The move that ties with Aoki's move
            
            // Update dp for each possible move Takahashi could make in this round
            for (int takahashiMove = 0; takahashiMove < 3; takahashiMove++) {
                // If Takahashi makes the winning move
                if (takahashiMove == winMove) {
                    dp[i][takahashiMove] = Math.max(dp[i-1][(takahashiMove+1)%3], dp[i-1][(takahashiMove+2)%3]) + 1;
                } 
                // If Takahashi makes the draw move
                else if (takahashiMove == drawMove) {
                    dp[i][takahashiMove] = Math.max(dp[i-1][(takahashiMove+1)%3], dp[i-1][(takahashiMove+2)%3]);
                }
            }
        }

        // Calculate the final result by taking the max value from the last round
        int ans = 0;
        for (int i = 0; i < 3; i++) {
            ans = Math.max(ans, dp[n][i]);
        }

        System.out.println(ans);
    }
}
",1
"import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        // Fast input/output setup
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
        int n = Integer.parseInt(br.readLine());
        int[] a = new int[n + 1];
        int[] pre = new int[n + 1];
        long ans = 0;

        // Reading input and building prefix XOR array
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(st.nextToken());
            pre[i] = pre[i - 1] ^ a[i];
        }

        // Calculating contribution of each bit position
        for (int k = 0; k < 32; k++) {
            int o = 0, z = 0;
            for (int i = 0; i <= n; i++) {
                if ((pre[i] >> k) % 2 == 1) {
                    o++;
                } else {
                    z++;
                }
            }
            ans += (1L << k) * o * z;
        }

        // Subtract individual element values from the result
        for (int i = 1; i <= n; i++) {
            ans -= a[i];
        }

        // Output the final result
        pw.println(ans);
        pw.flush();
        pw.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Variables to hold the ""rank"" (number of people younger than each)
        int a = 0, b = 0, c = 0;

        // Get the relationship between A and B
        char q = input.next().charAt(0);
        if (q == '<') {
            ++b; // A is younger than B, so B is older
        } else {
            ++a; // A is older than B, so A is older
        }

        // Get the relationship between A and C
        q = input.next().charAt(0);
        if (q == '<') {
            ++c; // A is younger than C, so C is older
        } else {
            ++a; // A is older than C, so A is older
        }

        // Get the relationship between B and C
        q = input.next().charAt(0);
        if (q == '<') {
            ++c; // B is younger than C, so C is older
        } else {
            ++b; // B is older than C, so B is older
        }

        // Now determine the middle brother based on the ""rank""
        if (a == 1) {
            System.out.println(""A"");
        } else if (b == 1) {
            System.out.println(""B"");
        } else {
            System.out.println(""C"");
        }

        input.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Read the number of families (N) and the number of babies (M)
        int N = sc.nextInt();
        int M = sc.nextInt();

        // Create an array to track if the first male has been born in each family
        boolean[] firstMaleBorn = new boolean[N + 1]; // Index 1-based, so we use N+1

        // Process each baby
        for (int i = 0; i < M; i++) {
            int family = sc.nextInt();   // Family number (1-based)
            char gender = sc.next().charAt(0); // Gender 'M' for male, 'F' for female

            // If the baby is male and it's the first male in this family
            if (gender == 'M') {
                if (!firstMaleBorn[family]) {
                    // This is the first male, name him Taro
                    System.out.println(""Yes"");
                    firstMaleBorn[family] = true; // Mark that this family has its first male born
                } else {
                    // Not the first male, can't be named Taro
                    System.out.println(""No"");
                }
            } else {
                // Female baby can't be named Taro
                System.out.println(""No"");
            }
        }

        sc.close();
    }
}
",1
"import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
        
        int N = Integer.parseInt(reader.readLine());
        int MG = Integer.parseInt(reader.readLine());

        boolean[][] adjG = new boolean[N][N];
        for (int i = 0; i < MG; i++) {
            StringTokenizer st = new StringTokenizer(reader.readLine());
            int u = Integer.parseInt(st.nextToken()) - 1;
            int v = Integer.parseInt(st.nextToken()) - 1;
            adjG[u][v] = adjG[v][u] = true;
        }

        int MH = Integer.parseInt(reader.readLine());
        boolean[][] adjH = new boolean[N][N];
        for (int i = 0; i < MH; i++) {
            StringTokenizer st = new StringTokenizer(reader.readLine());
            int u = Integer.parseInt(st.nextToken()) - 1;
            int v = Integer.parseInt(st.nextToken()) - 1;
            adjH[u][v] = adjH[v][u] = true;
        }

        int[][] A = new int[N][N];
        for (int i = 0; i < N - 1; i++) {
            StringTokenizer st = new StringTokenizer(reader.readLine());
            for (int j = i + 1; j < N; j++) {
                A[i][j] = Integer.parseInt(st.nextToken());
                A[j][i] = A[i][j]; // Fill the symmetric cost matrix
            }
        }

        // List of indices for permutations
        int[] indices = new int[N];
        for (int i = 0; i < N; i++) {
            indices[i] = i;
        }

        // Generate all permutations of the vertex labels
        List<List<Integer>> permutations = generatePermutations(indices);
        int result = Integer.MAX_VALUE;

        // For each permutation, calculate the cost to make G and H isomorphic
        for (List<Integer> perm : permutations) {
            int cost = 0;
            for (int i = 0; i < N; i++) {
                for (int j = i + 1; j < N; j++) {
                    boolean gEdge = adjG[perm.get(i)][perm.get(j)];
                    boolean hEdge = adjH[i][j];
                    if (gEdge != hEdge) {
                        cost += A[i][j]; // Add/remove edge cost
                    }
                }
            }
            result = Math.min(result, cost); // Track the minimum cost
        }

        writer.write(Integer.toString(result));
        writer.newLine();
        writer.flush();
        writer.close();
    }

    // Helper method to generate all permutations of the indices
    private static List<List<Integer>> generatePermutations(int[] elements) {
        List<List<Integer>> result = new ArrayList<>();
        permute(result, new ArrayList<>(), elements, new boolean[elements.length]);
        return result;
    }

    // Recursively generate permutations
    private static void permute(List<List<Integer>> result, List<Integer> current, int[] elements, boolean[] used) {
        if (current.size() == elements.length) {
            result.add(new ArrayList<>(current));
            return;
        }
        for (int i = 0; i < elements.length; i++) {
            if (!used[i]) {
                used[i] = true;
                current.add(elements[i]);
                permute(result, current, elements, used);
                used[i] = false;
                current.remove(current.size() - 1);
            }
        }
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int L = scanner.nextInt();
        int R = scanner.nextInt();
        
        // Check the conditions for hand raising
        if (L == 1 && R == 0) {
            System.out.println(""Yes"");  // Snuke is raising only his left hand.
        } else if (L == 0 && R == 1) {
            System.out.println(""No"");   // Snuke is raising only his right hand.
        } else {
            System.out.println(""Invalid"");  // Both hands or no hand raised.
        }
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the matrix N
        int N = scanner.nextInt();

        // Create and fill the transformation matrix A
        int[][] A = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j <= i; j++) {
                A[i][j] = scanner.nextInt();
                if (i != j) {
                    A[j][i] = A[i][j];  // Fill symmetric values
                }
            }
        }

        // Start with element 1
        int currentElement = 1;

        // Combine with elements 1 through N
        for (int i = 1; i <= N; i++) {
            currentElement = A[Math.max(currentElement, i) - 1][Math.min(currentElement, i) - 1];
        }

        // Output the final element
        System.out.println(currentElement);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        String T = sc.next();
        int modified = 0;
        char[] charArrayOfS = S.toCharArray();
        StringBuilder sb = new StringBuilder();
        int len = S.length();

        // First pass: change lexicographically larger characters
        for (int i = 0; i < len; i++) {
            if (charArrayOfS[i] > T.charAt(i)) {
                charArrayOfS[i] = T.charAt(i);
                sb.append(new String(charArrayOfS)).append(""\n"");
                modified++;
            }
        }

        // Second pass: fix remaining characters
        for (int i = len - 1; i >= 0; i--) {
            if (charArrayOfS[i] != T.charAt(i)) {
                charArrayOfS[i] = T.charAt(i);
                sb.append(new String(charArrayOfS)).append(""\n"");
                modified++;
            }
        }

        // Output the result
        System.out.println(modified);
        System.out.println(sb);
    }
}
",1
"import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input values A and B
        int A = scanner.nextInt();
        int B = scanner.nextInt();

        // Use a set to store distinct values of x
        Set<Integer> validX = new HashSet<>();

        // Case 1: x = 2A - B
        int x1 = 2 * A - B;
        validX.add(x1);

        // Case 2: x = (A + B) / 2 (only if A + B is even)
        if ((A + B) % 2 == 0) {
            int x2 = (A + B) / 2;
            validX.add(x2);
        }

        // Case 3: x = 2B - A
        int x3 = 2 * B - A;
        validX.add(x3);

        // Print the number of distinct x values
        System.out.println(validX.size());
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        String[] a = new String[n];
        int l = -1;
        int r = -1;
        int fatigue = 0;

        for (int i = 0; i < n; i++) {
            a[i] = sc.nextLine();
        }

        for (int i = 0; i < n; i++) {
            String[] parts = a[i].split("" "");
            int key = Integer.parseInt(parts[0]);
            String hand = parts[1];

            if (hand.equals(""L"")) {
                if (l == -1) {
                    l = key;
                } else {
                    fatigue += Math.abs(l - key);
                    l = key;
                }
            } else {
                if (r == -1) {
                    r = key;
                } else {
                    fatigue += Math.abs(r - key);
                    r = key;
                }
            }
        }

        System.out.println(fatigue);
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] ary = new int[n];
        int[] memo = new int[n];
        int[] sa = new int[n];
        long sum = 2 * n - 1; // Initial sum with all single and two-element subsequences
        
        // Reading the array
        for (int i = 0; i < n; i++) {
            ary[i] = sc.nextInt();
        }
        
        // Calculating differences between consecutive elements
        for (int i = 1; i < n; i++) {
            memo[i] = ary[i] - ary[i - 1];
        }
        
        // Identifying and counting valid subsequences
        for (int i = 2; i < n; i++) {
            if (memo[i] == memo[i - 1]) {
                sa[i] = sa[i - 1] + 1;
            }
        }
        
        // Summing up the valid subsequences
        for (int i = 0; i < n; i++) {
            sum += sa[i];
        }
        
        System.out.println(sum);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        
        StringBuilder result = new StringBuilder();
        
        for (int i = 1; i <= N; i++) {
            if (i % 3 == 0) {
                result.append(""x"");
            } else {
                result.append(""o"");
            }
        }
        
        System.out.println(result.toString());
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Read the number of points
        int N = sc.nextInt();
        
        // Arrays to store the coordinates of the points
        int[] X = new int[N];
        int[] Y = new int[N];
        
        // Reading the coordinates
        for (int i = 0; i < N; i++) {
            X[i] = sc.nextInt();
            Y[i] = sc.nextInt();
        }
        
        // Loop over each point
        for (int i = 0; i < N; i++) {
            int farthestPointID = -1;
            long maxDistance = -1;

            // Find the farthest point from the current point
            for (int j = 0; j < N; j++) {
                if (i != j) {
                    // Calculate the squared distance
                    long dist = (long)(X[i] - X[j]) * (X[i] - X[j]) + (long)(Y[i] - Y[j]) * (Y[i] - Y[j]);
                    
                    // Update the farthest point
                    if (dist > maxDistance || (dist == maxDistance && j + 1 < farthestPointID)) {
                        maxDistance = dist;
                        farthestPointID = j + 1;  // Store the ID (1-based)
                    }
                }
            }
            
            // Output the result for the current point
            System.out.println(farthestPointID);
        }
    }
}
",1
"import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();  // Number of beans
        Map<Integer, Integer> colorMinDeliciousness = new HashMap<>();

        // Process each bean
        for (int i = 0; i < N; i++) {
            int A = sc.nextInt();  // Deliciousness
            int C = sc.nextInt();  // Color

            // Track the minimum deliciousness for each color
            colorMinDeliciousness.put(C, Math.min(colorMinDeliciousness.getOrDefault(C, Integer.MAX_VALUE), A));
        }

        // Find the maximum value of the minimum deliciousness for any color
        int maxOfMinDeliciousness = 0;
        for (int minDeliciousness : colorMinDeliciousness.values()) {
            maxOfMinDeliciousness = Math.max(maxOfMinDeliciousness, minDeliciousness);
        }

        System.out.println(maxOfMinDeliciousness);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Input: A apples and P pieces of apple
        int A = sc.nextInt();
        int P = sc.nextInt();
        
        // Calculate total pieces of apple (each apple can be cut into 3 pieces)
        int totalPieces = P + 3 * A;
        
        // Calculate the maximum number of apple pies we can make (2 pieces per pie)
        int maxPies = totalPieces / 2;
        
        // Output the result
        System.out.println(maxPies);
    }
}
",1
"import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Scanner;

class Restaurant {
    String city;
    int score;
    int id;

    public Restaurant(String city, int score, int id) {
        this.city = city;
        this.score = score;
        this.id = id;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        ArrayList<Restaurant> restaurants = new ArrayList<>();

        // Read input
        for (int i = 0; i < N; i++) {
            String city = sc.next();
            int score = sc.nextInt();
            restaurants.add(new Restaurant(city, score, i + 1));
        }

        // Sort by city name in lexicographical order, and by score in descending order within the same city
        Collections.sort(restaurants, new Comparator<Restaurant>() {
            public int compare(Restaurant r1, Restaurant r2) {
                if (!r1.city.equals(r2.city)) {
                    return r1.city.compareTo(r2.city);
                } else {
                    return r2.score - r1.score;
                }
            }
        });

        // Print the sorted restaurant IDs
        for (Restaurant r : restaurants) {
            System.out.println(r.id);
        }
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // Read number of switches and bulbs
        int N = sc.nextInt();
        int M = sc.nextInt();
        
        // Read bulb connections
        int[][] switches = new int[M][];
        for (int i = 0; i < M; i++) {
            int k = sc.nextInt(); // Number of switches connected to bulb i
            switches[i] = new int[k];
            for (int j = 0; j < k; j++) {
                switches[i][j] = sc.nextInt() - 1; // Store zero-based index of switches
            }
        }
        
        // Read expected parity (0 or 1) for each bulb
        int[] p = new int[M];
        for (int i = 0; i < M; i++) {
            p[i] = sc.nextInt();
        }
        
        int validCombinations = 0;
        
        // Try all possible combinations of switch states (2^N combinations)
        for (int bit = 0; bit < (1 << N); bit++) {
            boolean allBulbsOn = true;
            
            for (int i = 0; i < M; i++) {
                int countOn = 0;
                
                // Count how many switches connected to bulb i are ""on""
                for (int j = 0; j < switches[i].length; j++) {
                    if ((bit & (1 << switches[i][j])) != 0) {
                        countOn++;
                    }
                }
                
                // Check if bulb i is on according to its parity condition
                if (countOn % 2 != p[i]) {
                    allBulbsOn = false;
                    break;
                }
            }
            
            if (allBulbsOn) {
                validCombinations++;
            }
        }
        
        // Output the number of valid combinations
        System.out.println(validCombinations);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        
        // Check if the number contains digit '9'
        if (N / 10 == 9 || N % 10 == 9) {
            System.out.println(""Yes"");
        } else {
            System.out.println(""No"");
        }
        
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); // number of groups
        int totalPeople = 0;
        
        // Process each group
        for (int i = 0; i < N; i++) {
            int l = sc.nextInt(); // starting seat of the group
            int r = sc.nextInt(); // ending seat of the group
            totalPeople += (r - l + 1); // number of seats occupied by this group
        }
        
        System.out.println(totalPeople); // total number of people
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        char X = sc.next().charAt(0); // First character (hex letter)
        char Y = sc.next().charAt(0); // Second character (hex letter)
        
        // Convert the characters to their hexadecimal values
        int valX = Character.getNumericValue(X);
        int valY = Character.getNumericValue(Y);
        
        // Compare the values and print the result
        if (valX < valY) {
            System.out.println(""<"");
        } else if (valX > valY) {
            System.out.println("">"");
        } else {
            System.out.println(""="");
        }
        
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int X = sc.nextInt(); // width of the seat
        int Y = sc.nextInt(); // length a person occupies
        int Z = sc.nextInt(); // gap between people and the end
        
        // The space occupied by one person including gaps on both sides is Y + Z
        int spacePerPerson = Y + Z;
        
        // The first person needs Z cm before sitting, so we reduce that once
        int availableSpace = X - Z;
        
        // Calculate how many people can fit
        int maxPeople = availableSpace / spacePerPerson;
        
        System.out.println(maxPeople);
        
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String N = sc.next(); // Read the 4-digit number as a string
        
        // Check if there are three or more consecutive same digits
        if (N.charAt(0) == N.charAt(1) && N.charAt(1) == N.charAt(2) || 
            N.charAt(1) == N.charAt(2) && N.charAt(2) == N.charAt(3)) {
            System.out.println(""Yes"");
        } else {
            System.out.println(""No"");
        }
        
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        
        // Base cases
        if (N == 0) {
            System.out.println(2);
            return;
        } else if (N == 1) {
            System.out.println(1);
            return;
        }
        
        // Lucas series calculation for N >= 2
        long[] lucas = new long[N + 1];
        lucas[0] = 2;
        lucas[1] = 1;
        
        for (int i = 2; i <= N; i++) {
            lucas[i] = lucas[i - 1] + lucas[i - 2];
        }
        
        System.out.println(lucas[N]);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.next();
        
        int A = input.charAt(0) - '0';
        int B = input.charAt(1) - '0';
        int C = input.charAt(2) - '0';
        int D = input.charAt(3) - '0';

        // Try all combinations of + and -
        if (A + B + C + D == 7) {
            System.out.println(A + ""+"" + B + ""+"" + C + ""+"" + D + ""=7"");
        } else if (A + B + C - D == 7) {
            System.out.println(A + ""+"" + B + ""+"" + C + ""-"" + D + ""=7"");
        } else if (A + B - C + D == 7) {
            System.out.println(A + ""+"" + B + ""-"" + C + ""+"" + D + ""=7"");
        } else if (A + B - C - D == 7) {
            System.out.println(A + ""+"" + B + ""-"" + C + ""-"" + D + ""=7"");
        } else if (A - B + C + D == 7) {
            System.out.println(A + ""-"" + B + ""+"" + C + ""+"" + D + ""=7"");
        } else if (A - B + C - D == 7) {
            System.out.println(A + ""-"" + B + ""+"" + C + ""-"" + D + ""=7"");
        } else if (A - B - C + D == 7) {
            System.out.println(A + ""-"" + B + ""-"" + C + ""+"" + D + ""=7"");
        } else if (A - B - C - D == 7) {
            System.out.println(A + ""-"" + B + ""-"" + C + ""-"" + D + ""=7"");
        }
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int A = sc.nextInt();
        int B = sc.nextInt();
        
        int sum = A + B;
        
        if (sum >= 10) {
            System.out.println(""error"");
        } else {
            System.out.println(sum);
        }
        
        sc.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        
        boolean[] charSet = new boolean[26];
        boolean allUnique = true;
        
        for (int i = 0; i < S.length(); i++) {
            int idx = S.charAt(i) - 'a';
            if (charSet[idx]) {
                allUnique = false;
                break;
            }
            charSet[idx] = true;
        }
        
        System.out.println(allUnique ? ""yes"" : ""no"");
    }
}
",1
"import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input
        int N = sc.nextInt();
        int[] s = new int[N];
        int totalSum = 0;
        for (int i = 0; i < N; i++) {
            s[i] = sc.nextInt();
            totalSum += s[i];
        }

        // If total sum is not a multiple of 10, we can use it directly.
        if (totalSum % 10 != 0) {
            System.out.println(totalSum);
            return;
        }

        // Sort scores to find the smallest non-multiple of 10.
        Arrays.sort(s);
        
        // Find the smallest score that is not a multiple of 10.
        for (int i = 0; i < N; i++) {
            if (s[i] % 10 != 0) {
                System.out.println(totalSum - s[i]);
                return;
            }
        }

        // If all scores are multiples of 10, output 0.
        System.out.println(0);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings S and T
        String S = scanner.next();
        String T = scanner.next();

        // Check if S equals ""AtCoder"" and T equals ""Land""
        if (""AtCoder"".equals(S) && ""Land"".equals(T)) {
            System.out.println(""Yes"");
        } else {
            System.out.println(""No"");
        }

        scanner.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read number of people and time per transaction
        int N = scanner.nextInt();
        int A = scanner.nextInt();

        // Read arrival times
        int[] T = new int[N];
        for (int i = 0; i < N; i++) {
            T[i] = scanner.nextInt();
        }

        // Initialize current time
        int currentTime = 0;

        // Array to store finish times
        int[] finishTimes = new int[N];

        // Process each person
        for (int i = 0; i < N; i++) {
            if (T[i] > currentTime) {
                // If the person arrives after the booth is free
                currentTime = T[i];
            }
            // Calculate finish time
            finishTimes[i] = currentTime + A;
            // Update current time for next person's turn
            currentTime = finishTimes[i];
        }

        // Output finish times
        for (int i = 0; i < N; i++) {
            System.out.println(finishTimes[i]);
        }

        scanner.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        int M = scanner.nextInt();
        String[] stands = new String[N];

        for (int i = 0; i < N; i++) {
            stands[i] = scanner.next();
        }

        int minStands = N; // Initialize with the maximum number of stands
        // Iterate over all possible combinations of stands
        for (int i = 1; i < (1 << N); i++) {
            boolean[] flavorsCovered = new boolean[M];
            int standsCount = Integer.bitCount(i);
            for (int j = 0; j < N; j++) {
                if ((i & (1 << j)) != 0) {
                    // If the j-th bit is set in i, include stand j in the combination
                    for (int k = 0; k < M; k++) {
                        if (stands[j].charAt(k) == 'o') {
                            flavorsCovered[k] = true;
                        }
                    }
                }
            }
            boolean allCovered = true;
            for (int k = 0; k < M; k++) {
                if (!flavorsCovered[k]) {
                    allCovered = false;
                    break;
                }
            }
            if (allCovered) {
                minStands = Math.min(minStands, standsCount);
            }
        }

        System.out.println(minStands);

        scanner.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read number of aliens N and disinfectant capacity M
        int N = scanner.nextInt();
        int M = scanner.nextInt();

        // Array to store the number of hands each alien has
        int[] hands = new int[N];
        for (int i = 0; i < N; i++) {
            hands[i] = scanner.nextInt();
        }

        // Variable to keep track of the remaining disinfectant
        int remainingDisinfectant = M;
        // Variable to count the number of aliens who can disinfect all their hands
        int aliensDisinfected = 0;

        // Iterate through each alien
        for (int i = 0; i < N; i++) {
            if (remainingDisinfectant >= hands[i]) {
                remainingDisinfectant -= hands[i];
                aliensDisinfected++;
            } else {
                // If not enough disinfectant is left for the current alien, break the loop
                break;
            }
        }

        // Output the result
        System.out.println(aliensDisinfected);

        // Close the scanner
        scanner.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Read the input string S
        String S = scanner.nextLine();
        
        int upperCount = 0;
        int lowerCount = 0;

        // Count the number of uppercase and lowercase letters
        for (char c : S.toCharArray()) {
            if (Character.isUpperCase(c)) {
                upperCount++;
            } else if (Character.isLowerCase(c)) {
                lowerCount++;
            }
        }

        // Convert the string based on the counts
        String result;
        if (upperCount > lowerCount) {
            result = S.toUpperCase();
        } else {
            result = S.toLowerCase();
        }

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        scanner.close();

        int size = (int) Math.pow(3, N);
        char[][] carpet = new char[size][size];
        generateCarpet(carpet, N, 0, 0, size);

        for (int i = 0; i < size; i++) {
            System.out.println(new String(carpet[i]));
        }
    }

    private static void generateCarpet(char[][] carpet, int level, int x, int y, int size) {
        if (level == 0) {
            carpet[x][y] = '#';
            return;
        }

        int subSize = size / 3;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (i == 1 && j == 1) {
                    fillWhite(carpet, x + subSize, y + subSize, subSize);
                } else {
                    generateCarpet(carpet, level - 1, x + i * subSize, y + j * subSize, subSize);
                }
            }
        }
    }

    private static void fillWhite(char[][] carpet, int x, int y, int size) {
        for (int i = x; i < x + size; i++) {
            for (int j = y; j < y + size; j++) {
                carpet[i][j] = '.';
            }
        }
    }
}
",1
"import java.util.Scanner;
import java.math.BigInteger;

public class Main {
    static final long MOD = 998244353;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long N = scanner.nextLong();
        scanner.close();

        // Number of digits in N
        int k = Long.toString(N).length();
        
        // Compute 10^k % MOD
        long tenPowerK = modExp(10, k, MOD);
        
        // Compute 10^(kN) % MOD
        long tenPowerKN = modExp(tenPowerK, N, MOD);
        
        // Compute the geometric sum mod MOD: (10^(kN) - 1) / (10^k - 1) % MOD
        long numerator = (tenPowerKN - 1 + MOD) % MOD;
        long denominator = (tenPowerK - 1 + MOD) % MOD;
        long denominatorInv = modInverse(denominator, MOD);
        long geometricSumMod = numerator * denominatorInv % MOD;
        
        // The result is N * geometricSumMod % MOD
        long result = N % MOD * geometricSumMod % MOD;
        
        System.out.println(result);
    }

    // Function to perform modular exponentiation
    static long modExp(long base, long exp, long mod) {
        long result = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                result = result * base % mod;
            }
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }

    // Function to find modular inverse using Fermat's little theorem
    static long modInverse(long a, long mod) {
        return modExp(a, mod - 2, mod);
    }
}
",1
"import java.util.*;

public class Main {
    static Scanner scanner = new Scanner(System.in);
    static int readInt() { return scanner.nextInt(); }
    static long readLong() { return scanner.nextLong(); }
    static String readString() { return scanner.next(); }

    public static void main(String[] args) {
        int n = readInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = readInt() - 1;

        int[] stack = new int[n + 1];
        int[] arrivedDepth = new int[n];
        int[] reachables = new int[n];
        long sum = 0;
        Arrays.fill(arrivedDepth, -1);
        int size;

        for (int i = 0; i < n; i++) {
            if (arrivedDepth[i] == -2) continue; // Node already processed
            size = 0;
            stack[size++] = i;
            arrivedDepth[i] = 0;
            boolean loop = false;

            while (true) {
                int elem = stack[size - 1];
                int child = a[elem];
                stack[size++] = child;
                if (arrivedDepth[child] == -2) break;
                if (arrivedDepth[child] == -1) {
                    arrivedDepth[child] = arrivedDepth[elem] + 1;
                } else {
                    loop = true;
                    break;
                }
            }

            if (loop) {
                int d = size;
                int loopTil = stack[--size];
                while (stack[size - 1] != loopTil)
                    size--;
                int count = d - size;
                for (int j = size; j < d; j++) {
                    arrivedDepth[stack[j]] = -2;
                    reachables[stack[j]] = count;
                }
                sum += (long) count * count;
            }

            size--;
            while (size > 0) {
                int elem = stack[--size];
                arrivedDepth[elem] = -2;
                reachables[elem] = reachables[a[elem]] + 1;
                sum += reachables[elem];
            }
        }

        System.out.println(sum);
    }

    static String toString(int[] stack, int size) {
        return Arrays.toString(Arrays.copyOf(stack, size));
    }
}
",1
"import java.util.*;

public class Main {

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        boolean isFoundM = false;
        for (int i = 0; i < S.length(); i++) {
            if (S.charAt(i) == 'M') {
                isFoundM = true;
            }
            if (S.charAt(i) == 'R') {
                if (isFoundM) {
                    System.out.println(""No"");
                    return;
                } else {
                    System.out.println(""Yes"");
                    return;
                }
            }
        }
    }
}
",1
"import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        String T = sc.next();
        
        int lenS = S.length();
        int lenT = T.length();
        
        // Iterate over possible values of w
        for (int w = 1; w < lenS; w++) {
            // Iterate over possible values of c
            for (int c = 1; c <= w; c++) {
                StringBuilder formedT = new StringBuilder();
                
                // Form the string T' by taking c-th characters from each w-length substring
                for (int i = c - 1; i < lenS; i += w) {
                    if (i < lenS) {
                        formedT.append(S.charAt(i));
                    }
                }
                
                // Compare formedT with T
                if (formedT.toString().equals(T)) {
                    System.out.println(""Yes"");
                    return;
                }
            }
        }
        
        // If no pair (c, w) works, print ""No""
        System.out.println(""No"");
    }
}
",1
"import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(reader.readLine().trim());
        int[] a = Arrays.stream(reader.readLine().trim().split(""\\s+""))
                        .mapToInt(Integer::parseInt)
                        .toArray();
        long[] b = Arrays.stream(reader.readLine().trim().split(""\\s+""))
                        .mapToLong(Long::parseLong)
                        .toArray();
        
        long[] s = new long[n];
        long[] m = new long[n];
        
        for (int i = 0; i < n; i++) {
            int boxIndex = a[i] - 1; // converting to 0-based index
            s[boxIndex] += b[i];
            m[boxIndex] = Math.max(m[boxIndex], b[i]);
        }
        
        long ans = 0;
        for (int i = 0; i < n; i++) {
            if (m[i] > 0) {
                ans += s[i] - m[i];
            }
        }
        
        System.out.println(ans);
    }
}
",1
"import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner();
        
        int n = sc.nextInt();
        long t = sc.nextLong();
        char[] directions = sc.next().toCharArray();
        TreeMap<Long, Integer> lefts = new TreeMap<>();
        List<Long> rights = new ArrayList<>();
        
        // Read positions and categorize ants
        for (int i = 0; i < n; i++) {
            long x = sc.nextLong();
            if (directions[i] == '0') {
                lefts.put(x, lefts.getOrDefault(x, 0) + 1);
            } else {
                rights.add(x);
            }
        }
        
        // Accumulate counts for left-moving ants
        lefts.put(Long.MIN_VALUE, 0); // Sentinel for easy range queries
        int sum = 0;
        for (long key : lefts.keySet()) {
            sum += lefts.get(key);
            lefts.put(key, sum);
        }
        
        // Calculate number of passing pairs
        long ans = 0;
        for (long rightPos : rights) {
            ans += lefts.floorEntry(rightPos + 2 * t).getValue() - lefts.floorEntry(rightPos).getValue();
        }
        
        System.out.println(ans);
    }
}

class Scanner {
    BufferedReader br;
    StringTokenizer st = new StringTokenizer("""");
    StringBuilder sb = new StringBuilder();
    
    public Scanner() {
        try {
            br = new BufferedReader(new InputStreamReader(System.in));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public int nextInt() {
        return Integer.parseInt(next());
    }
    
    public long nextLong() {
        return Long.parseLong(next());
    }
    
    public double nextDouble() {
        return Double.parseDouble(next());
    }
    
    public String next() {
        try {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(br.readLine());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return st.nextToken();
    }
}
",1
"import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    public static void main(String args[]) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] ss = br.readLine().trim().split("" "");
        long N = Long.parseLong(ss[0]);
        long K = Long.parseLong(ss[1]);
        br.close();

        long mod = 998244353L;
        long bmod = BigInteger.valueOf(N).pow(2).modInverse(BigInteger.valueOf(mod)).longValue();
        long bm2 = BigInteger.valueOf(2).modInverse(BigInteger.valueOf(mod)).longValue();

        long p = 1;
        long q = 0;

        long c1 = ((N - 1) % mod * (N - 1) % mod + 1) % mod;
        c1 = (c1 * bmod) % mod;
        long c2 = (2L * bmod) % mod;
        long c3 = (c2 * (N - 1)) % mod;
        long c4 = (c2 * (N - 2) + c1) % mod;

        for (int i = 0; i < K; i++) {
            long p1 = (c1 * p) % mod + (c3 * q) % mod;
            long q1 = (c2 * p) % mod + (c4 * q) % mod;
            p = p1 % mod;
            q = q1 % mod;
        }

        long c5 = (N * (N + 1)) % mod;
        c5 *= bm2;
        c5 %= mod;
        c5 = (c5 - 1 + mod) % mod;

        long t = (p + (c5 * q) % mod) % mod;
        System.out.println(t);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        
        // Extract the numeric part of the string
        int number = Integer.parseInt(S.substring(3, 6));
        
        // Check if the contest number is valid
        if ((number >= 1 && number <= 315) || (number >= 317 && number <= 349)) {
            System.out.println(""Yes"");
        } else {
            System.out.println(""No"");
        }
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int A = sc.nextInt();
        int B = sc.nextInt();
        
        if (A != B) {
            System.out.println(6 - A - B);
        } else {
            System.out.println(-1);
        }
    }
}
",1
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        
        int[] A = new int[N];
        int[] B = new int[M];
        
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextInt();
        }
        
        for (int i = 0; i < M; i++) {
            B[i] = sc.nextInt();
        }
        
        // Merge A and B
        int[] C = new int[N + M];
        System.arraycopy(A, 0, C, 0, N);
        System.arraycopy(B, 0, C, N, M);
        
        // Sort C
        Arrays.sort(C);
        
        // Check if any two consecutive elements in C belong to A
        Set<Integer> setA = new HashSet<>();
        for (int i : A) {
            setA.add(i);
        }
        
        for (int i = 1; i < C.length; i++) {
            if (setA.contains(C[i - 1]) && setA.contains(C[i])) {
                System.out.println(""Yes"");
                return;
            }
        }
        
        System.out.println(""No"");
    }
}
",1
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt();
        int T = sc.nextInt();
        
        int[] A = new int[T];
        for (int i = 0; i < T; i++) {
            A[i] = sc.nextInt();
        }
        
        // Track the rows, columns, and diagonals
        int[] rowCount = new int[N];
        int[] colCount = new int[N];
        int diag1Count = 0;
        int diag2Count = 0;
        
        // 2D grid position map
        Map<Integer, int[]> positionMap = new HashMap<>();
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                positionMap.put(N * i + j + 1, new int[]{i, j});
            }
        }
        
        // Marking cells and checking for Bingo
        for (int t = 0; t < T; t++) {
            int num = A[t];
            int[] pos = positionMap.get(num);
            int row = pos[0];
            int col = pos[1];
            
            // Mark the row and column
            rowCount[row]++;
            colCount[col]++;
            
            // Mark diagonals if applicable
            if (row == col) diag1Count++;
            if (row + col == N - 1) diag2Count++;
            
            // Check if Bingo is achieved
            if (rowCount[row] == N || colCount[col] == N || diag1Count == N || diag2Count == N) {
                System.out.println(t + 1);
                return;
            }
        }
        
        // If no Bingo is achieved
        System.out.println(-1);
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String S = sc.next();
        
        // Check the first three characters to identify the majority character
        char majority = S.charAt(0);
        if (S.charAt(1) == S.charAt(0)) {
            majority = S.charAt(0);
        } else if (S.charAt(2) == S.charAt(0)) {
            majority = S.charAt(0);
        } else {
            majority = S.charAt(1);
        }
        
        // Find the differing character
        for (int i = 0; i < S.length(); i++) {
            if (S.charAt(i) != majority) {
                System.out.println(i + 1);  // Output the 1-based index
                return;
            }
        }
    }
}
",1
"import java.util.Scanner;

public class Main{
    public static void main(String[]args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] p = new int[n];
        for(int i = 0; i < n; i++){
            p[i] = sc.nextInt();
        }
        int q = sc.nextInt();
        int[] a = new int[q];
        int[] b = new int[q];
        for(int i = 0; i < q; i++){
            a[i] = sc.nextInt();
            b[i] = sc.nextInt();
        }

        for(int i = 0; i < q; i++){
            int aindex = linearSearch(p, a[i]);
            int bindex = linearSearch(p, b[i]);
            if(aindex < bindex){
                System.out.println(a[i]);
            } else {
                System.out.println(b[i]);
            }
        }
        sc.close();
    }

    public static int linearSearch(int[] array, int value){
        for(int i = 0; i < array.length; i++){
            if(array[i] == value){
                return i;
            }
        }
        return -1;
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();  // Length of the string S
        String S = sc.next();  // The original string
        int Q = sc.nextInt();  // Number of operations

        // Create a map that tracks character replacements
        char[] replacementMap = new char[26];
        for (char i = 'a'; i <= 'z'; i++) {
            replacementMap[i - 'a'] = i;
        }

        // Process all operations
        for (int i = 0; i < Q; i++) {
            char c = sc.next().charAt(0);
            char d = sc.next().charAt(0);

            // Update the map to replace all occurrences of 'c' with 'd'
            for (char j = 'a'; j <= 'z'; j++) {
                if (replacementMap[j - 'a'] == c) {
                    replacementMap[j - 'a'] = d;
                }
            }
        }

        // Build the final string after applying the replacements
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < N; i++) {
            char currentChar = S.charAt(i);
            result.append(replacementMap[currentChar - 'a']);
        }

        // Output the final string
        System.out.println(result.toString());

        sc.close();
    }
}
",1
"import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner();
        int n = sc.nextInt();
        HashMap<Integer, Integer> counts = new HashMap<>();
        
        // Process each number to remove square factors
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            for (int j = 2; j * j <= x; j++) {
                while (x % (j * j) == 0) {
                    x /= j * j;  // Remove the square factor
                }
            }
            counts.put(x, counts.getOrDefault(x, 0) + 1);  // Count occurrences of the reduced value
        }
        
        long ans = 0;
        
        // Handle case when the number is 0 separately if present
        if (counts.containsKey(0)) {
            long current = counts.get(0);
            ans += n * current - current * (current + 1) / 2;
            counts.remove(0);
        }
        
        // Count pairs for all other values
        for (int x : counts.values()) {
            ans += (x - 1L) * x / 2;  // Calculate combinations of pairs
        }
        
        System.out.println(ans);
    }
}

// Custom Scanner for fast input handling
class Scanner {
    BufferedReader br;
    StringTokenizer st = new StringTokenizer("""");

    public Scanner() {
        try {
            br = new BufferedReader(new InputStreamReader(System.in));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public long nextLong() {
        return Long.parseLong(next());
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }

    public String next() {
        try {
            while (!st.hasMoreTokens()) {
                st = new StringTokenizer(br.readLine());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return st.nextToken();
    }
}
",1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        
        // Find the index of the first and second '|'
        int firstPipe = s.indexOf('|');
        int secondPipe = s.lastIndexOf('|');
        
        // Remove the characters between the two pipes, including the pipes themselves
        String result = s.substring(0, firstPipe) + s.substring(secondPipe + 1);
        
        // Print the result
        System.out.println(result);
    }
}
",1
"import java.util.ArrayList;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        ArrayList<Integer> numbers = new ArrayList<>();
        
        // Read integers until we get 0 (which is guaranteed to be the last input)
        while (sc.hasNextInt()) {
            int num = sc.nextInt();
            numbers.add(num);
            if (num == 0) {
                break;
            }
        }
        
        // Print the numbers in reverse order
        for (int i = numbers.size() - 1; i >= 0; i--) {
            System.out.println(numbers.get(i));
        }
        
        sc.close();
    }
}
",1
"import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Read input sizes
        int N = sc.nextInt();
        int[] A = new int[N];
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextInt();
        }

        int M = sc.nextInt();
        int[] B = new int[M];
        for (int i = 0; i < M; i++) {
            B[i] = sc.nextInt();
        }

        int L = sc.nextInt();
        int[] C = new int[L];
        for (int i = 0; i < L; i++) {
            C[i] = sc.nextInt();
        }

        int Q = sc.nextInt();
        int[] X = new int[Q];
        for (int i = 0; i < Q; i++) {
            X[i] = sc.nextInt();
        }

        // Store all possible sums of elements from A and B in a set
        HashSet<Integer> abSums = new HashSet<>();
        for (int a : A) {
            for (int b : B) {
                abSums.add(a + b);
            }
        }

        // For each query, check if there's a sum in abSums such that sum + c = X[i]
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < Q; i++) {
            boolean found = false;
            for (int c : C) {
                if (abSums.contains(X[i] - c)) {
                    result.append(""Yes\n"");
                    found = true;
                    break;
                }
            }
            if (!found) {
                result.append(""No\n"");
            }
        }

        // Output the result
        System.out.print(result);
    }
}
",1